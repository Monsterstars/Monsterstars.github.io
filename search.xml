<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[junit assert断言解析]]></title>
    <url>%2F2019%2F11%2F09%2Fjunit%2F</url>
    <content type="text"><![CDATA[junit源码↑↑↑↑↑↑↑↑↑↑点我点我 引入包，以下两种方式都是OK的，看个人喜好，我倾向于使用第二种，会更加清晰直观。下面的代码我都会用第二种 12import static org.junit.Assert.*;import org.junit.Assert; Assert是断言的意思，我更喜欢理解为”猜测”，比断言要顺口和通俗。如果猜测错误，则抛出java.lang.AssertionError异常 Assert.fail()1让测试直接出错，抛出 AssertionError 。 Assert.fail(String message)1让测试直接出错，并在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertNull(Object object)1猜测 object 为 null，如果不为 null ，抛出 AssertionError 。 Assert.assertNull(String message, Object object)12猜测 object 为 null。如果不为 null ，在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertNotNull(Object object)1猜测 object 不为 null，如果为 null ，抛出 AssertionError 。 Assert.assertNotNull(String message, Object object)12猜测 object 不为 null。如果为 null ，在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertSame(Object expected, Object actual)12猜测 expected 对象和 actual 对象引用的是同一个对象。如果不同，抛出 AssertionError 。 Assert.assertSame(String message, Object expected, Object actual)12猜测 expected 对象和 actual 对象引用的是同一个对象。如果不同，在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertNotSame(Object expected, Object actual)12猜测 expected 对象和 actual 对象引用不同的对象。如果相同，抛出 AssertionError 。 Assert.assertNotSame(String message, Object expected, Object actual)12猜测 expected 对象和 actual 对象引用不同的对象。如果相同，在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertTrue(boolean condition)12猜测 condition 为 true 。如果为 false ，抛出 AssertionError 。 Assert.assertTrue(String message, boolean condition)12猜测 condiiton 为 true 。如果为 false ， 在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertFalse(boolean condition)12猜测 condition 为 false 。如果为 true ， 抛出 AssertionError 。 Assert.assertFalse(String message, boolean condition)12猜测 condiiton 为 false 。如果为 true ， 在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertEquals(long expected, long actual)12猜测两个 long 类型 expected 和 actual 的值相等。如果不相等，抛出 AssertionError 。 Assert.assertEquals(String message, long expected, long actual)12猜测两个 long 类型 expected 和 actual 的值相等。如果不相等，在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertNotEquals(long unexpected, long actual)12猜测两个 long 类型 unexpected 和 actual 的值不相等。如果相等，抛出 AssertionError 。 Assert.assertNotEquals(String message, long unexpected, long actual)12猜测两个 long 类型 expected 和 actual 的值不相等。如果相等，在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertEquals(Object expected, Object actual)12猜测两个对象相等。如果不相等，抛出 AssertionError 。 Assert.assertEquals(String message, Object expected, Object actual)12猜测两个对象相等。如果不相等，在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertNotEquals(Object unexpected, Object actual)12猜测两个对象不相等。如果相等，抛出 AssertionError 。 Assert.assertNotEquals(String message, Object unexpected, Object actual)12猜测两个对象不相等。如果相等，在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertEquals(float expected, float actual, float delta)12345678910猜测两个 float 类型 expect 和 actual 在 delta 偏差值下相等如果不相等，抛出 AssertionError 。//例1Assert.assertEquals(1.1, 1.3, 0.2) //Pass//例2Assert.assertEquals(1.3, 1.1, 0.2) //Pass//例3Assert.assertEquals(1.1, 1.3, 0.1) //AssertionError//例4Assert.assertEquals(1.3, 1.1, 0.1) //AssertionError Assert.assertEquals(String message, float expected, float actual, float delta)12345678910猜测两个 float 类型 expect 和 actual 在 delta 偏差值下相等如果不相等，在抛出 AssertionError 时输出 message 作为错误提示信息。//例1Assert.assertEquals(&quot;Not equal !&quot;,1.1, 1.3, 0.2) //Pass//例2Assert.assertEquals(&quot;Not equal !&quot;,1.3, 1.1, 0.2) //Pass//例3Assert.assertEquals(&quot;Not equal !&quot;,1.1, 1.3, 0.1) //AssertionError : Not equal !//例4Assert.assertEquals(&quot;Not equal !&quot;,1.3, 1.1, 0.1) //AssertionError : Not equal ! Assert.assertNotEquals(float unexpected, float actual, float delta)12345678910猜测两个 float 类型 unexpected 和 actual 在 delta 偏差值下不相等如果相等，抛出 AssertionError 。//例1Assert.assertNotEquals(1.1, 1.3, 0.1) //Pass//例2Assert.assertNotEquals(1.3, 1.1, 0.1) //Pass//例3Assert.assertNotEquals(1.1, 1.3, 0.2) //AssertionError//例4Assert.assertNotEquals(1.3, 1.1, 0.2) //AssertionError Assert.assertNotEquals(String message, float unexpected, float actual, float delta)12345678910猜测两个 float 类型 expect 和 actual 在 delta 偏差值下不相等如果相等，在抛出 AssertionError 时输出 message 作为错误提示信息。//例1Assert.assertNotEquals(&quot;Equal !&quot;,1.1, 1.3, 0.1) //Pass//例2Assert.assertNotEquals(&quot;Equal !&quot;,1.3, 1.1, 0.1) //Pass//例3Assert.assertNotEquals(&quot;Equal !&quot;,1.1, 1.3, 0.2) //AssertionError : Equal !//例4Assert.assertNotEquals(&quot;Equal !&quot;,1.3, 1.1, 0.2) //AssertionError : Equal ! Assert.assertEquals(long expected, long actual, long delta)12猜测两个 long 类型 expected 和 actual 在 delta 偏差值下相等如果不相等，抛出 AssertionError 。 Assert.assertEquals(String message, long expected, long actual, long delta)12猜测两个 long 类型 expect 和 actual 在 delta 偏差值下相等如果不相等，在抛出 AssertionError 时输出 message 作为错误提示信息。 Assert.assertNotEquals(long unexpected, long actual, long delta)12猜测两个 long 类型 unexpected 和 actual 在 delta 偏差值下不相等如果相等，抛出 AssertionError 。 Assert.assertNotEquals(String message, long unexpected, long actual, long delta)12猜测两个 long 类型 expect 和 actual 在 delta 偏差值下不相等如果相等，在抛出 AssertionError 时输出 message 作为错误提示信息。 31~37 - Assert.assertArrayEquals(T[] expected, T[] actual) 1234猜测两个相同类型的数组的元素一一对应相等。如果不相等，抛出 AssertionError 。T 支持的类型有 int、byte、char、long、short、boolean、Object 38~44 - Assert.assertArrayEquals(String message, T[] expected, T[] actual) 1234猜测两个相同类型的数组的元素一一对应相等。如果不相等，在抛出 AssertionError 时输出 message 作为错误提示信息。T 支持的类型有 int、byte、char、long、short、boolean、Object 44~45 - Assert.assertArrayEquals(T[] expected, T[] actual, T delta) 1234猜测两个相同类型的数组的元素，在 delte 偏差值下一一对应相等。如果不相等，抛出 AssertionError 。T 支持的类型有 float、double 46~47 - Assert.assertArrayEquals(String message, T[] expected, T[] actual, T delta) 1234猜测两个相同类型的数组的元素，在 delte 偏差值下一一对应相等。如果不相等，在抛出 AssertionError 时输出 message 作为错误提示信息。T 支持的类型有 float、double 48 - Assert.assertThat(T actual, Matcher&lt;? super T&gt; matcher) 123456789101112猜测 actual 的值符合规则 matcher。如果不符合，抛出 AssertionError 。//例1Assert.assertThat(1, is(1)); //Pass//例2Assert.assertThat(1, greaterThan(0)); //Pass//例3Assert.assertThat(1, is(0)); //AssertionError//例4Assert.assertThat(1, greaterThan(1)); //AssertionError注：Matcher 十分灵活，需要引入包import static org.hamcrest.Matchers.*;，更多使用可参考文档： org.hamcrest.Matchers 49 - Assert.assertThat(String reason, T actual, Matcher&lt;? super T&gt; matcher) 1234567891011猜测 actual 的值符合规则 matcher。如果不符合，在抛出 AssertionError 时输出 reason 作为错误提示信息。//例1Assert.assertThat(&quot;not match reason: ...&quot;, 1, is(1)); //Pass//例2Assert.assertThat(&quot;not match reason: ...&quot;,1, greaterThan(0)); //Pass//例3Assert.assertThat(&quot;not match reason: ...&quot;,1, is(0)); //AssertionError : not match reason : ...//例4Assert.assertThat(&quot;not match reason: ...&quot;,1, greaterThan(1)); //AssertionError : not match reason : ...]]></content>
  </entry>
  <entry>
    <title><![CDATA[IdeaNest 创意社区]]></title>
    <url>%2F2019%2F06%2F10%2Fjsjds%2F</url>
    <content type="text"><![CDATA[宣传视频： 关于我 国立华侨大学 软件工程大二在读 独立视频制作者 啥都感兴趣 联系方式： qq: 1093846898 wechat: czh-0526 e-mail: 1093846898@qq.com 觉得本文不错？请支持我]]></content>
  </entry>
  <entry>
    <title><![CDATA[为邻——基于GNSS定位技术的Android移动App]]></title>
    <url>%2F2019%2F06%2F08%2Fwei-lin%2F</url>
    <content type="text"><![CDATA[宣传视频： 作品安装说明 手机浏览器访问我们的个人网站“ https://monsterstars.github.io/static/zhsq.apk” 点击“下载客户端”按钮弹出下载链接 使用下载的apk包并进行安装与权限赋予 打开安装完毕app进行根据页面提示进行登录注册 作品效果图Android前端地图API接口部分代码Android前端Adapter部分代码后端数据库接口部分代码后端数据库表Android界面主页界面设计Android界面任务界面设计Android界面个人中心界面设计 作品思路创意：项目的创意起源于我们生活中一个很微小的细节，因大学校园区域较大，同学们往来菜鸟驿站拿取快递较为不便，出现了互助“雏形”，即部分同学在拿取自己快递的同时在群聊中提出可顺手帮取的信息，有此需求的其他同学支付一定的金额换取方便。也因此基本需求衍生出了不少其余业务，如搬置物品、代买零食、代购日用品等小需求。在各种需求而产生的各类互助群聊中来去穿梭而感到麻烦不已的三个人一拍即合，决定做一款能够方便发布接取互助任务的手机App来方便大家。在与指导老师联系并调研讨论后，我们寻找到了问题的根源，即当代人与同一社群成员交流度急剧下降，而导致的互助困难问题。在这种情况下许多人选择通过微信、QQ互助群，这样不仅交流十分困难，效率也十分低下。在准备将其作为一款定位为“社群互助”的App的同时，我们也同时结合社会上的动态，决定加入呼救功能以在互助之余提供一个给予老人、小孩、女性等弱势人群的呼救功能，充分加强社群互助与用户使用度。 策划：开发开始前，我们将 App 开发分为4个板块，产品功能探讨及流程设计；产品 UI 界面设计及编码；数据库设计及编码；前后端数据交互。并进行了前后端的分工和框架的选择。 在开发开始后，我们计划在每周末开会讨论各分块所遇困难及收获技巧。各个模块的负责人会汇报本周内进展，使各模块成员可互相掌握他人进度，有利于后期各个模块间的沟通交流，分工整合。 根据项目实际，灵活调整计划表。项目推进的过程中会遇到很多我们事先无法预料的困难，如果某个模块因为未知的困难而导致进度延误，可能会影响到其他模块，得益于每周的例会制度，我们可以灵活的调整进度表，安排下一步的工作。 制作:前端开发：主要使用 JAVA 与 xml 语言编写页面逻辑与页面布局，使用 Fragment 呈现 UI 视图，使用 Activity 管理 Fragment。使用 OkHttp 和 Gson 库进行 http 链接与解析 Json 数据。使用 Google 推荐的 Material Design 设计制作页面。 后端开发：在阿里云上部署，使用 java 语言开发和 mysql 数据库，通过 PHPmyadmin 实现在线数据库管理，后台搭建使用 spring，springmvc，mybatis 框架作为底层架构实现数据库连接，前后端请求的数据交换格式，使用统一的标准 json 格式。 合成:依照前期使用Axure设计的原型进行编码。我们采用了Git开源式版本管理系统进行前端项目整合。因为Git中有各种繁杂的指令需要我们花很长时间去理解尤其是分支的概念，在大量的网上阅读文档和练习后终于上手Git。后期使用OkHttp库与部署在购置的云服务器上的数据库进行对接。 优化:经过数个月的学习，开发，我们推出了第一个版本，该版本已经初步实现了我们预期设计是功能，但是还存在以下几个方面需要完善和改进： 电信物联网与我们自己的后台服务器之间使用的是 http 协议，存在一定的安全隐患。 且与Android高版本不兼容。正在进行https认证申请。 物联网的终端产品需要进行缩小，并且对外观进行美化。已出具设计初稿 初步开发时仅以可用性为目标，导致界面能够使用但不够美观，我们已邀请数字媒体技术专业同学帮助对APP的UI进行优化。 在进行优化的同时，我们以人员推销和广告策略对APP进行了商业推广，细节如下：人员推销：由开发团队内部的市场推广负责人员，前往各高校、社区进行游说推广，开展宣讲会等社区活动，同时提高 APP 知名度。 广告策略：应以网络推广为主，辅以其他形式的广告推广，增强针对主要客户群体的曝光度。 设计重点难点重点： 原型设计部分：App主色确定为绿色。主题色选用绿色（#61A584），橙色（#F59A23）为部分点缀。由于App主要特色为“求助求救”功能，而绿色象征安全、希望与和平，与App的功能相辅相成。 前端部分：统一使用最新Android版本即API28；调用百度地图API；使用OkHttp框架进行前后端交接； 后端部分：使用spring，springmvc，mybatis 框架作为底层架构；接口和实现类分为bean ,dao ,service ,controller；使用springmvc扫描controller，spring扫描其他组件；@Autowired 注释，对类成员变量、方法及构造函数进行标注，完成自动装配的工作；配置扫描器，将MyBatis接口的实现加入到ioc容器中；利用mybatis-generator在bean和dao层自动生成代码，大大减轻了代码书写的工作量；前后端请求的数据交换格式，使用统一的标准 json 格式。 服务器配置部分：后台服务器我们选择使用阿里云的服务器，使用Linux操作系统 难点： 原型设计部分： App主色难以确定，颜色有千种万种，主色的确定需要万里挑一。每个App都有自己的主色，主色的选择与该App的需求与功能应用有一定的联系。解决：参考大量不同功能App的界面，观察主色与应用的联系，阅读相关书籍及网络资料，学习最佳配色方案。 App的图标设计，对图标的设计没有经验，也没有想法，无从下手。解决：参考大量的App的图标设计，观察到总共分为三类： 纯文字类,字体需要设计/创新 (例如：淘宝，支付宝) 纯图片类（例如：QQ，淘票票，优酷，微博，飞猪） 图片+文字类（例如：京东） 最后选用了第三类，图片+文字类，文字加以一定的设计，配上与APP功能相关的标志。 前端部分： 遇到最多的是版本问题，由于我们三个开发者在写UI前端界面的时候用的虚拟机版本不同导致我们的UI界面始终不能统一, 且分别绘制了不同的自定义控件所以三个人呈现出来了三个不同风格的作品，皆与原型有所偏移。解决：及时发现了问题并统一了我们的UI 采用了Git开源式版本管理系统，而我们之前只对SVN有所了解，学习难度大，学习成本较高。解决：通过大量的网上阅读文档和练习成功上手Git 调用百度地图的API：上手后才知道百度地图其实有许多的坑，申请百度地图平台时SHA1码一定要正确，导入LBS包后要加入library中，AndroidManifest中除了加入权限还要加入标签等等问题，这些细节稍不注意就会使地图初始化不能定位，我们当时也困扰代码编译时没有报错，但地图一直无法定位，最后发现是没有加入so文件导入。解决：细致检查代码和参阅对比多个blog 前后端交互：采用了OkHttp框架，但我们在实际运用中发现引用的框架已经停止维护许久。无法实现与后端交互数据的功能。解决：框架基础上重新封装了一个类，成功的与后端进行了数据交互。 后端部分： 修改数据库：在开发过程中，遇到了必须要修改数据库的情况，这就必须要重写后端的逻辑控制代码，重新使用mybatis-generator生成代码，出现了修改架构而出现报错现象。解决：在经历数个小时的debug之后，发现再重新使用mybatis-generator生成代码时，会在原来的文件下继续生成代码，而不是覆盖该文件的代码。发现问题之后，将原文件删除，重新使用mybatis-generator生成代码，再进行修改。 服务器部分： Linux系统学习与操作：Linux操作系统与Windows相比有更高的安全性，但是随之而来的是操作的复杂性。Linux的操作是使用命令行控制，没有像Windows那样的界窗系统。解决：查阅相关资料后，决定在服务器上部署宝塔Linux应用，宝塔Linux给我们提供了像Windows那样的窗口操作界面，通过它，我们可以仅仅通过单击鼠标就可以完成mysql，tomcat，php，PHPmyadmin等常用软件的安装和管理。 命名规则区别：由于服务器与本地的数据库使用不同的版本，导致两边的服务器命名规则不一样。服务器上的数据库不允许数据库名中带“.”号。在部署期间，由于服务器搭建与代码编写人员间的沟通不及时，导致这个问题被隐藏了下来。解决：通过查看日志等多方手段排查才发现并解决了这个问题。 关于我 国立华侨大学 软件工程大二在读 独立视频制作者 啥都感兴趣 联系方式： qq: 1093846898 wechat: czh-0526 e-mail: 1093846898@qq.com 觉得本文不错？请支持我]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用国外vps主机搭建Shadowsocks实现科学上网]]></title>
    <url>%2F2019%2F06%2F06%2Fshadowsocks-build%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC+Spring+MyBatis框架学习笔记]]></title>
    <url>%2F2019%2F06%2F04%2Fspringmvc-spring-mybatis%2F</url>
    <content type="text"><![CDATA[视频地址GitHub仓库地址 SSM-CRUDssm:SpringMVC+Spring+MyBatisCRUD：Create（创建）Retrieve（查询）Update（更新）Delete（删除）功能点 分页 数据校验 : jquery前端校验+JSR303后端校验 ajax Rest风格的URI；使用HTTP协议请求方式的动词，来表示对资源的操作（GET（查询），POST（新增），PUT（修改），DELETE（删除）） 技术点 基础框架-ssm（SpringMVC+Spring+MyBatis） 数据库-MySQL 前端框架-bootstrap快速搭建简洁美观的界面 项目的依赖管理-Maven 分页-pagehelper 逆向工程-MyBatis Generator 基础环境搭建 创建一个maven工程 引入项目依赖的jar包 spring springmvc mybatis 数据库连接池，驱动包 其他（jstl，servlet-api，junit） 引入bootstrap前端框架 编写ssm整合的关键配置文件 web.xml，spring,springmvc,mybatis，使用mybatis的逆向工程生成对应的bean以及mapper 测试mapper CRUD-查询 查询 访问index.jsp页面 index.jsp页面发送出查询员工列表请求 EmployeeController来接受请求，查出员工数据 来到list.jsp页面进行展示 pageHelper分页插件完成分页查询功能 URI：/emps 查询-ajax index.jsp页面直接发送ajax请求进行员工分页数据的查询 服务器将查出的数据，以json字符串的形式返回给浏览器 浏览器收到js字符串。可以使用js对json进行解析，使用js通过dom增删改改变页面。 返回json。实现客户端的无关性。 新增 新增-逻辑 在index.jsp页面点击”新增” 弹出新增对话框 去数据库查询部门列表，显示在对话框中 用户输入数据，并进行校验jquery前端校验，ajax用户名重复校验，重要数据（后端校验(JSR303)，唯一约束）； 完成保存 URI: /emp/{id} GET 查询员工 /emp POST 保存员工 /emp/{id} PUT 修改员工 /emp/{id} DELETE 删除员工 修改 修改-逻辑 点击编辑 弹出用户修改的模态框（显示用户信息） 点击更新，完成用户修改 删除 删除-逻辑 单个删除 URI:/emp/{id} DELETE 批量删除 SSM框架： Spring Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 SpringMVC Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 MyBatis MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的XML或注解用于配置和原始映射，将接口和Java 的POJOs（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。 框架各层联系： SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层四层 使用spring MVC负责请求的转发和视图管理 spring实现业务对象管理，mybatis作为数据对象的持久化引擎 原理：SpringMVC： 客户端发送请求到DispacherServlet（分发器） 由DispacherServlet控制器查询HanderMapping，找到处理请求的Controller Controller调用业务逻辑处理后，返回ModelAndView DispacherSerclet查询视图解析器，找到ModelAndView指定的视图 视图负责将结果显示到客户端 Spring：我们平时开发接触最多的估计就是IOC容器，它可以装载bean（也就是我们Java中的类，当然也包括service dao里面的），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。 Mybatis：mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。 使用方法：要完成一个功能： 先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。 写Mapper.xml（Mybatis），其中定义你的功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。 写Mapper.java，将Mapper.xml中的操作按照id映射成Java函数。 写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。 写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。 写JSP页面调用，请求哪些参数，需要获取什么数据。 DataBase ===&gt; Entity ===&gt;Mapper.xml===&gt;Mapper.Java ===&gt; Service.java ===&gt; Controller.java ===&gt; Jsp. SpringMVC Spring MyBatis 拥有控制器，作用跟Struts类似，接收外部请求，解析参数传给服务层 容器属于协调上下文，管理对象间的依赖，提供事务机制 属于orm持久层框架，将业务实体与数据表联合起来 控制层，想当与Struts的作用 控制反转和依赖注入创建对象交由容器管理，达到了解耦的作用 主要用来操作数据库（数据库的增删改查） IOC:控制反转，是一种降低对象之间耦合关系的设计思想，面试的时候最好能说出来个例子，加深理解。例子：租房子，以前租房子需要一个房子一个房子找，费时费力，然后现在加入一个房屋中介，把你需要的房型告诉中介，就可以直接选到需要的房子，中介就相当于spring容器。 AOP:面向切面编程，是面向对象开发的一种补充，它允许开发人员在不改变原来模型的基础上动态的修改模型以满足新的需求，如：动态的增加日志、安全或异常处理等。AOP使业务逻辑各部分间的耦合度降低，提高程序可重用性，提高开发效率。]]></content>
  </entry>
  <entry>
    <title><![CDATA[后端架构师技术图谱]]></title>
    <url>%2F2019%2F06%2F01%2Farchitect-awesome%2F</url>
    <content type="text"><![CDATA[《后端架构师技术图谱》 推荐: 《Java技术书籍大全》 - awesome-java-books 从初级开发者到资深架构师，看这些书就够了 数据结构 队列 集合 链表、数组 字典、关联数组 栈 树 二叉树 完全二叉树 平衡二叉树 二叉查找树（BST） 红黑树 B，B+，B*树 LSM 树 BitSet 常用算法 排序、查找算法 选择排序 冒泡排序 插入排序 快速排序 归并排序 希尔排序 堆排序 计数排序 桶排序 基数排序 二分查找 Java 中的排序工具 布隆过滤器 字符串比较 KMP 算法 深度优先、广度优先 贪心算法 回溯算法 剪枝算法 动态规划 朴素贝叶斯 推荐算法 最小生成树算法 最短路径算法 并发 Java 并发 多线程 线程安全 一致性、事务 事务 ACID 特性 事务的隔离级别 MVCC 锁 Java中的锁和同步类 公平锁 &amp; 非公平锁 悲观锁 乐观锁 &amp; CAS ABA 问题 CopyOnWrite容器 RingBuffer 可重入锁 &amp; 不可重入锁 互斥锁 &amp; 共享锁 死锁 操作系统 计算机原理 CPU 多级缓存 进程 线程 协程 Linux 设计模式 设计模式的六大原则 23种常见设计模式 应用场景 单例模式 责任链模式 MVC IOC AOP UML 微服务思想 康威定律 运维 &amp; 统计 &amp; 技术支持 常规监控 APM 统计分析 持续集成(CI/CD) Jenkins 环境分离 自动化运维 Ansible puppet chef 测试 TDD 理论 单元测试 压力测试 全链路压测 A/B 、灰度、蓝绿测试 虚拟化 KVM Xen OpenVZ 容器技术 Docker 云技术 OpenStack DevOps 文档管理 中间件 Web Server Nginx OpenResty Tengine Apache Httpd Tomcat 架构原理 调优方案 Jetty 缓存 本地缓存 客户端缓存 服务端缓存 Web缓存 Memcached Redis 架构 回收策略 Tair 消息队列 消息总线 消息的顺序 RabbitMQ RocketMQ ActiveMQ Kafka Redis 消息推送 ZeroMQ 定时调度 单机定时调度 分布式定时调度 RPC Dubbo Thrift gRPC 数据库中间件 Sharding Jdbc 日志系统 日志搜集 配置中心 API 网关 网络 协议 OSI 七层协议 TCP/IP HTTP HTTP2.0 HTTPS 网络模型 Epoll Java NIO kqueue 连接和短连接 框架 零拷贝（Zero-copy） 序列化(二进制协议) Hessian Protobuf 数据库 基础理论 数据库设计的三大范式 MySQL 原理 InnoDB 优化 索引 聚集索引, 非聚集索引 复合索引 自适应哈希索引(AHI) explain NoSQL MongoDB Hbase 搜索引擎 搜索引擎原理 Lucene Elasticsearch Solr sphinx 性能 性能优化方法论 容量评估 CDN 网络 连接池 性能调优 大数据 流式计算 Storm Flink Kafka Stream 应用场景 Hadoop HDFS MapReduce Yarn Spark 安全 web 安全 XSS CSRF SQL 注入 Hash Dos 脚本注入 漏洞扫描工具 验证码 DDoS 防范 用户隐私信息保护 序列化漏洞 加密解密 对称加密 哈希算法 非对称加密 服务器安全 数据安全 数据备份 网络隔离 内外网分离 登录跳板机 授权、认证 RBAC OAuth2.0 双因素认证（2FA） 单点登录(SSO) 常用开源框架 开源协议 日志框架 Log4j、Log4j2 Logback ORM 网络框架 Web 框架 Spring 家族 工具框架 分布式设计 扩展性设计 稳定性 &amp; 高可用 硬件负载均衡 软件负载均衡 限流 应用层容灾 跨机房容灾 容灾演练流程 平滑启动 数据库扩展 读写分离模式 分片模式 服务治理 服务注册与发现 服务路由控制 分布式一致 CAP 与 BASE 理论 分布式锁 分布式一致性算法 PAXOS Zab Raft Gossip 两阶段提交、多阶段提交 幂等 分布式一致方案 分布式 Leader 节点选举 TCC(Try/Confirm/Cancel) 柔性事务 分布式文件系统 唯一ID 生成 全局唯一ID 一致性Hash算法 设计思想 &amp; 开发模式 DDD(Domain-driven Design - 领域驱动设计) 命令查询职责分离(CQRS) 贫血，充血模型 Actor 模式 响应式编程 Reactor RxJava Vert.x DODAF2.0 Serverless Service Mesh 项目管理 架构评审 重构 代码规范 代码 Review RUP 看板管理 SCRUM 敏捷开发 极限编程（XP） 结对编程 PDCA 循环质量管理 FMEA管理模式 通用业务术语 技术趋势 政策、法规 法律 严格遵守刑法253法条 架构师素质 团队管理 招聘 资讯 行业资讯 公众号列表 博客 团队博客 个人博客 综合门户、社区 问答、讨论类社区 行业数据分析 专项网站 其他类 推荐参考书 在线电子书 纸质书 开发方面 架构方面 技术管理方面 基础理论 工具方面 大数据方面 技术资源 开源资源 手册、文档、教程 在线课堂 会议、活动 常用APP 找工作 工具 代码托管 文件服务 综合云服务商 VPS （Toc generated by simple-php-github-toc ） 数据结构队列 《java队列——queue详细分析》 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。 《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》 集合 《Java Set集合的详解》 链表、数组 《Java集合详解–什么是List》 字典、关联数组 《Java map 详解 - 用法、遍历、排序、常用API等》 栈 《java数据结构与算法之栈（Stack）设计与实现》 《Java Stack 类》 《java stack的详细实现分析》 Stack 是线程安全的。 内部使用数组保存数据，不够时翻倍。 树二叉树每个节点最多有两个叶子节点。 《二叉树》 完全二叉树 《完全二叉树》 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。 平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 《浅谈数据结构-平衡二叉树》 《浅谈算法和数据结构: 八 平衡查找树之2-3树》 二叉查找树（BST）二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。 《浅谈算法和数据结构: 七 二叉查找树》 红黑树 《最容易懂得红黑树》 添加阶段后，左旋或者右旋从而再次达到平衡。 《浅谈算法和数据结构: 九 平衡查找树之红黑树》 B，B+，B*树MySQL是基于B+树聚集索引组织表 《B-树，B+树，B*树详解》 《B-树，B+树与B*树的优缺点比较》 B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。LSM 树 LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。 《LSM树 VS B+树》 B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。 LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。 《LSM树（Log-Structured Merge Tree）存储引擎》 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。 Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。 BitSet经常用于大规模数据的排重检查。 《Java Bitset类》 《Java BitSet（位集）》 常用算法 《常见排序算法及对应的时间复杂度和空间复杂度》 排序、查找算法 《常见排序算法及对应的时间复杂度和空间复杂度》 选择排序 《Java中的经典算法之选择排序（SelectionSort）》 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。 冒泡排序 《冒泡排序的2种写法》 相邻元素前后交换、把最大的排到最后。 时间复杂度 O(n²) 插入排序 《排序算法总结之插入排序》 快速排序 《坐在马桶上看算法：快速排序》 一侧比另外一次都大或小。归并排序 《图解排序算法(四)之归并排序》 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 希尔排序TODO 堆排序 《图解排序算法(三)之堆排序》 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。 计数排序 《计数排序和桶排序》 和桶排序过程比较像，差别在于桶的数量。 桶排序 《【啊哈！算法】最快最简单的排序——桶排序》 《排序算法（三）：计数排序与桶排序》 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。 每个桶单独进行排序，然后再遍历每个桶。 基数排序按照个位、十位、百位、…依次来排。 《排序算法系列：基数排序》 《基数排序》 二分查找 《二分查找(java实现)》 要求待查找的序列有序。 时间复杂度 O(logN)。 《java实现二分查找-两种方式》 while + 递归。Java 中的排序工具 《Arrays.sort和Collections.sort实现原理解析》 Collections.sort算法调用的是合并排序。 Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。 布隆过滤器常用于大数据的排重，比如email，url 等。核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。优点：空间和时间效率都很高。缺点：随着存入的元素数量增加，误算率随之增加。 《布隆过滤器 – 空间效率很高的数据结构》 《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》 《基于Redis的布隆过滤器的实现》 基于 Redis 的 Bitmap 数据结构。 《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》 使用Java中的 BitSet 类 和 加权和hash算法。 字符串比较KMP 算法KMP：Knuth-Morris-Pratt算法（简称KMP）核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。 《字符串匹配的KMP算法》 深度优先、广度优先 《广度优先搜索BFS和深度优先搜索DFS》 贪心算法 《算法：贪婪算法基础》 《常见算法及问题场景——贪心算法》 回溯算法 《 五大常用算法之四：回溯法》 剪枝算法 《α-β剪枝算法》 动态规划 《详解动态规划——邹博讲动态规划》 《动态规划算法的个人理解》 朴素贝叶斯 《带你搞懂朴素贝叶斯分类算法》 P(B|A)=P(A|B)P(B)/P(A) 《贝叶斯推断及其互联网应用1》 《贝叶斯推断及其互联网应用2》 推荐算法 《推荐算法综述》 《TOP 10 开源的推荐系统简介》 最小生成树算法 《算法导论–最小生成树（Kruskal和Prim算法）》 最短路径算法 《Dijkstra算法详解》 并发Java 并发 Java 并发知识合集 JAVA并发知识图谱 多线程 《40个Java多线程问题总结》 线程安全 《Java并发编程——线程安全及解决机制简介》 一致性、事务事务 ACID 特性 《数据库事务ACID特性》 事务的隔离级别 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。 序列化：所有事物串行处理（牺牲了效率） 《理解事务的4种隔离级别》 数据库事务的四大特性及事务隔离级别 《MySQL的InnoDB的幻读问题 》 幻读的例子非常清楚。 通过 SELECT … FOR UPDATE 解决。 《一篇文章带你读懂MySQL和InnoDB》 图解脏读、不可重复读、幻读问题。 MVCC 《【mysql】关于innodb中MVCC的一些理解》 innodb 中 MVCC 用在 Repeatable-Read 隔离级别。 MVCC 会产生幻读问题（更新时异常。） 《轻松理解MYSQL MVCC 实现机制》 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间 每次只操作比当前版本小（或等于）的 行。 锁Java中的锁和同步类 《Java中的锁分类》 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 《Java并发之AQS详解》 《Java中信号量 Semaphore》 有数量控制 申请用 acquire，申请不要则阻塞；释放用 release。 《java开发中的Mutex vs Semaphore》 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。 公平锁 &amp; 非公平锁公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。 《公平锁与非公平锁》 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。 悲观锁悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。 《【MySQL】悲观锁&amp;乐观锁》 乐观锁的方式：版本号+重试方式 悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。 《Mysql查询语句使用select.. for update导致的数据库死锁分析》 mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。 锁相同数据的不同索引条件可能会引起死锁。 《Mysql并发时经典常见的死锁原因及解决方法》 乐观锁 &amp; CAS 《乐观锁的一种实现方式——CAS》 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。 ABA 问题由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。 《Java CAS 和ABA问题》 《Java 中 ABA问题及避免》 AtomicStampedReference 和 AtomicStampedReference。 CopyOnWrite容器可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。 《JAVA中写时复制(Copy-On-Write)Map实现》 实现读写分离，读取发生在原始数据上，写入发生在副本上。 不用加锁，通过最终一致实现一致性。 《聊聊并发-Java中的Copy-On-Write容器》 RingBuffer 《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》 可重入锁 &amp; 不可重入锁 《可重入锁和不可重入锁》 通过简单代码举例说明可重入锁和不可重入锁。 可重入锁指同一个线程可以再次获得之前已经获得的锁。 可重入锁可以用户避免死锁。 Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock 《ReenTrantLock可重入锁（和synchronized的区别）总结》 synchronized 使用方便，编译器来加锁，是非公平锁。 ReenTrantLock 使用灵活，锁的公平性可以定制。 相同加锁场景下，推荐使用 synchronized。 互斥锁 &amp; 共享锁互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。 《ReadWriteLock场景应用》 死锁 《“死锁”四个必要条件的合理解释》 互斥、持有、不可剥夺、环形等待。 Java如何查看死锁？ JConsole 可以识别死锁。 java多线程系列：死锁及检测 jstack 可以显示死锁。 操作系统计算机原理 《操作系统基础知识——操作系统的原理，类型和结构》 CPU多级缓存典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。 《从Java视角理解CPU缓存和伪共享》 进程TODO 线程 《线程的生命周期及状态转换详解》 协程 《终结python协程—-从yield到actor模型的实现》 线程的调度是由操作系统负责，协程调度是程序自行负责 与线程相比，协程减少了无谓的操作系统切换. 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换. Linux 《Linux 命令大全》 设计模式设计模式的六大原则 《设计模式的六大原则》 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。 合成复用原则：尽量使用合成/聚合,而不是使用继承。 23种常见设计模式 《设计模式》 《23种设计模式全解析》 《设计模式类图与示例》 应用场景 《细数JDK里的设计模式》 结构型模式： 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC； 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy 创建模式: 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。 工厂方法：就是 一个返* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。 行为模式： 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。 空对象模式：如 java.util.Collections#emptyList()。 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。 《Spring-涉及到的设计模式汇总》 《Mybatis使用的设计模式》 单例模式 《单例模式的三种实现 以及各自的优缺点》 《单例模式－－反射－－防止序列化破坏单例模式》 使用枚举类型。 责任链模式TODO MVC 《MVC 模式》 模型(model)－视图(view)－控制器(controller) IOC 《理解 IOC》 《IOC 的理解与解释》 正向控制：传统通过new的方式。反向控制，通过容器注入对象。 作用：用于模块解耦。 DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。 AOP 《轻松理解AOP(面向切面编程)》 《Spring AOP详解》 《Spring AOP的实现原理》 Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。 《Spring AOP 实现原理与 CGLIB 应用》 Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 UML 《UML教程》 微服务思想 《微服务架构设计》 《微服务架构技术栈选型手册》 康威定律 《微服务架构的理论基础 - 康威定律》 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。 《微服务架构核⼼20讲》 运维 &amp; 统计 &amp; 技术支持常规监控 《腾讯业务系统监控的修炼之路》 监控的方式：主动、被动、旁路(比如舆情监控) 监控类型： 基础监控、服务端监控、客户端监控、监控、用户端监控 监控的目标：全、块、准 核心指标：请求量、成功率、耗时 《开源还是商用？十大云运维监控工具横评》 Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。 《监控报警系统搭建及二次开发经验》 命令行监控工具 《常用命令行监控工具》 top、sar、tsar、nload 《20个命令行工具监控 Linux 系统性能》 《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》 APMAPM — Application Performance Management 《Dapper，大规模分布式系统的跟踪系统》 CNCF OpenTracing，中文版 主要开源软件，按字母排序 Apache SkyWalking CAT CNCF jaeger Pinpoint Zipkin 《开源APM技术选型与实战》 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。 统计分析 《流量统计的基础：埋点》 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度 《APP埋点常用的统计工具、埋点目标和埋点内容》 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。 《美团点评前端无痕埋点实践》 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 持续集成(CI/CD) 《持续集成是什么？》 《8个流行的持续集成工具》 Jenkins 《使用Jenkins进行持续集成》 环境分离开发、测试、生成环境分离。 《开发环境、生产环境、测试环境的基本理解和区》 自动化运维Ansible 《Ansible中文权威指南》 《Ansible基础配置和企业级项目实用案例》 puppet 《自动化运维工具——puppet详解》 chef 《Chef 的安装与使用》 测试TDD 理论 《深度解读 - TDD（测试驱动开发）》 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践. 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； 单元测试 《Java单元测试之JUnit篇》 《JUnit 4 与 TestNG 对比》 TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 《单元测试主要的测试功能点》 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 压力测试 《Apache ab 测试使用指南》 《大型网站压力测试及优化方案》 《10大主流压力/负载/性能测试工具推荐》 《真实流量压测工具 tcpcopy应用浅析》 《nGrinder 简易使用教程》 全链路压测 《京东618：升级全链路压测方案，打造军演机器人ForceBot》 《饿了么全链路压测的探索与实践》 《四大语言，八大框架｜滴滴全链路压测解决之道》 《全链路压测经验》 A/B 、灰度、蓝绿测试 《技术干货 | AB 测试和灰度发布探索及实践》 《nginx 根据IP 进行灰度发布》 《蓝绿部署、A/B 测试以及灰度发布》 虚拟化 《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》 KVM 《KVM详解，太详细太深入了，经典》 《【图文】KVM 虚拟机安装详解》 Xen 《Xen虚拟化基本原理详解》 OpenVZ 《开源Linux容器 OpenVZ 快速上手指南》 容器技术Docker 《几张图帮你理解 docker 基本原理及快速入门》 《Docker 核心技术与实现原理》 《Docker 教程》 云技术OpenStack 《OpenStack构架知识梳理》 DevOps 《一分钟告诉你究竟DevOps是什么鬼？》 《DevOps详解》 文档管理 Confluence-收费文档管理系统 GitLab? Wiki 中间件Web ServerNginx 《Ngnix的基本学习-多进程和Apache的比较》 Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。 《nginx与Apache的对比以及优缺点》 nginx只适合静态和反向代理，不适合处理动态请求。 OpenResty 官方网站 《浅谈 OpenResty》 通过 Lua 模块可以在Nginx上进行开发。 agentzh 的 Nginx 教程 Tengine 官方网站 Apache Httpd 官方网站 Tomcat架构原理 《TOMCAT原理详解及请求过程》 《Tomcat服务器原理详解》 《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》 《四张图带你了解Tomcat系统架构》 《JBoss vs. Tomcat: Choosing A Java Application Server》 Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。 Jboss 实现全部了JEE特性，软件开源免费、文档收费。 调优方案 《Tomcat 调优方案》 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； 《tomcat http协议与ajp协议》 《AJP与HTTP比较和分析》 AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。 并发高时，AJP协议优于HTTP协议。 Jetty 《Jetty 的工作原理以及与 Tomcat 的比较》 《jetty和tomcat优势比较》 架构比较:Jetty的架构比Tomcat的更为简单。 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 缓存 《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》 本地缓存 《HashMap本地缓存》 《EhCache本地缓存》 堆内、堆外、磁盘三级缓存。 可按照缓存空间容量进行设置。 按照时间、次数等过期策略。 《Guava Cache》 简单轻量、无堆外、磁盘缓存。 《Nginx本地缓存》 《Pagespeed—懒人工具，服务器端加速》 客户端缓存 《浏览器端缓存》 主要是利用 Cache-Control 参数。 《H5 和移动端 WebView 缓存机制解析与实战》 服务端缓存Web缓存 nuster - nuster cache varnish - varnish cache squid - squid cache Memcached 《Memcached 教程》 《深入理解Memcached原理》 采用多路复用技术提高并发性。 slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。 《Memcached软件工作原理》 《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》 《memcache 中 add 、 set 、replace 的区别》 区别在于当key存在还是不存在时，返回值是true和false的。 《memcached全面剖析》 Redis 《Redis 教程》 《redis底层原理》 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。 《Redis持久化方式》 RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。 AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。 也可以两者结合使用。 《分布式缓存–序列3–原子操作与CAS乐观锁》 架构 《Redis单线程架构》 回收策略 《redis的回收策略》 Tair 官方网站 《Tair和Redis的对比》 特点：可以配置备份节点数目，通过异步同步到备份节点 一致性Hash算法。 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。 几种存储引擎: MDB，完全内存性，可以用来存储Session等数据。 Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作 LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。 Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。 消息队列 《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》 RabbitMQ 消费者默认是推模式（也支持拉模式）。 Kafka 默认是拉模式。 Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。 Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。 《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》 消息总线消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。 《消息总线VS消息队列》 消息的顺序 《如何保证消费者接收消息的顺序》 RabbitMQ支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。 《RabbitMQ的应用场景以及基本原理介绍》 《消息队列之 RabbitMQ》 《RabbitMQ之消息确认机制（事务+Confirm）》 RocketMQJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。 《RocketMQ 实战之快速入门》 《RocketMQ 源码解析》 ActiveMQ纯Java实现，兼容JMS，可以内嵌于Java应用中。 《ActiveMQ消息队列介绍》 Kafka高吞吐量、采用拉模式。适合高IO场景，比如日志同步。 官方网站 《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》 《Kafka分区机制介绍与示例》 Redis 消息推送生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。 《Redis学习笔记之十：Redis用作消息队列》 ZeroMQ TODO 定时调度单机定时调度 《linux定时任务cron配置》 《Linux cron运行原理》 fork 进程 + sleep 轮询 《Quartz使用总结》 《Quartz源码解析 —- 触发器按时启动原理》 《quartz原理揭秘和源码解读》 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。 分布式定时调度 《这些优秀的国产分布式任务调度系统，你用过几个？》 opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares 《Quartz任务调度的基本实现原理》 Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 《Elastic-Job-Lite 源码解析》 《Elastic-Job-Cloud 源码解析》 RPC 《从零开始实现RPC框架 - RPC原理及实现》 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。 《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》 Dubbo 官方网站 dubbo实现原理简单介绍 SPI TODO Thrift 官方网站 《Thrift RPC详解》 支持多语言，通过中间语言定义接口。 gRPC服务端可以认证加密，在外网环境下，可以保证数据安全。 官方网站 《你应该知道的RPC原理》 数据库中间件Sharding Jdbc 官网 源码解析 日志系统日志搜集 《从零开始搭建一个ELKB日志收集系统》 《用ELK搭建简单的日志收集分析系统》 《日志收集系统-探究》 配置中心 Apollo - 携程开源的配置中心应用 Spring Boot 和 Spring Cloud 支持推、拉模式更新配置 支持多种语言 《基于zookeeper实现统一配置管理》 《 Spring Cloud Config 分布式配置中心使用教程》 servlet 3.0 异步特性可用于配置中心的客户端 《servlet3.0 新特性——异步处理》 API 网关主要职责：请求转发、安全认证、协议转换、容灾。 《API网关那些儿》 《谈API网关的背景、架构以及落地方案》 《使用Zuul构建API Gateway》 《Spring Cloud Gateway 源码解析》 《HTTP API网关选择之一Kong介绍》 网络协议OSI 七层协议 《OSI七层协议模型、TCP/IP四层模型学习笔记》 TCP/IP 《深入浅出 TCP/IP 协议》 《TCP协议中的三次握手和四次挥手》 HTTP 《http协议详解(超详细)》 HTTP2.0 《HTTP 2.0 原理详细分析》 《HTTP2.0的基本单位为二进制帧》 利用二进制帧负责传输。 多路复用。 HTTPS 《https原理通俗了解》 使用非对称加密协商加密算法 使用对称加密方式传输数据 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。 《八大免费SSL证书-给你的网站免费添加Https安全加密》 网络模型 《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。 《select、poll、epoll之间的区别总结》 select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。 select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。 select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。 poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。 《select，poll，epoll比较 》 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。 《深入理解Java NIO》 NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务 《BIO与NIO、AIO的区别》 《两种高效的服务器设计模型：Reactor和Proactor模型》 Epoll 《epoll使用详解（精髓）》 Java NIO 《深入理解Java NIO》 《Java NIO编写Socket服务器的一个例子》 kqueue 《kqueue用法简介》 连接和短连接 《TCP/IP系列——长连接与短连接的区别》 框架 《Netty原理剖析》 Reactor 模式介绍。 Netty 是 Reactor 模式的一种实现。 零拷贝（Zero-copy） 《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。 序列化(二进制协议)Hessian 《Hessian原理分析》Binary-RPC;不仅仅是序列化 Protobuf 《Protobuf协议的Java应用例子》Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。 《Protocol Buffers序列化协议及应用》 * 关于协议的解释；缺点：可读性差; 《简单的使用 protobuf 和 protostuff》 protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。 数据库基础理论数据库设计的三大范式 《数据库的三大范式以及五大约束》 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性； 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情； 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）； MySQL原理 《MySQL的InnoDB索引原理详解》 《MySQL存储引擎－－MyISAM与InnoDB区别》 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁 《myisam和innodb索引实现的不同》 InnoDB 《一篇文章带你读懂Mysql和InnoDB》 优化 《MySQL36条军规》 《MYSQL性能优化的最佳20+条经验》 《SQL优化之道》 《mysql数据库死锁的产生原因及解决办法》 《导致索引失效的可能情况》 《 MYSQL分页limit速度太慢优化方法》 原则上就是缩小扫描范围。 索引聚集索引, 非聚集索引 《MySQL 聚集索引/非聚集索引简述》 《MyISAM和InnoDB的索引实现》 MyISAM 是非聚集，InnoDB 是聚集 复合索引 《复合索引的优点和注意事项》 文中有一处错误： 对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引 原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。 《MySQL查询where条件的顺序对查询效率的影响》 自适应哈希索引(AHI) 《InnoDB存储引擎——自适应哈希索引》 explain 《MySQL 性能优化神器 Explain 使用分析》 NoSQLMongoDB MongoDB 教程 《Mongodb相对于关系型数据库的优缺点》 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越； 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方； Hbase 《简明 HBase 入门教程（开篇）》 《深入学习HBase架构原理》 《传统的行存储和（HBase）列存储的区别》 《Hbase与传统数据库的区别》 空数据不存储，节省空间，且适用于并发。 《HBase Rowkey设计》 rowkey 按照字典顺序排列，便于批量扫描。 通过散列可以避免热点。 搜索引擎搜索引擎原理 《倒排索引–搜索引擎入门》 Lucene 《Lucene入门简介》 Elasticsearch 《Elasticsearch学习，请先看这一篇！》 《Elasticsearch索引原理》 Solr 《 Apache Solr入门教程》 《elasticsearch与solr比较》 sphinx 《Sphinx 的介绍和原理探索》 性能性能优化方法论 《15天的性能优化工作，5方面的调优经验》 代码层面、业务层面、数据库层面、服务器层面、前端优化。 《系统性能优化的几个方面》 容量评估 《联网性能与容量评估的方法论和典型案例》 《互联网架构，如何进行容量设计？》 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS CDN 网络 《CDN加速原理》 《国内有哪些比较好的 CDN？》 连接池 《主流Java数据库连接池比较与开发配置实战》 性能调优 《九大Java性能调试工具，必备至少一款》 大数据流式计算Storm 官方网站 《最详细的Storm入门教程》 Flink 《Flink之一 Flink基本原理介绍》 Kafka Stream 《Kafka Stream调研：一种轻量级流计算模式》 应用场景例如： 广告相关实时统计； 推荐系统用户画像标签实时更新； 线上服务健康状况实时监测； 实时榜单； 实时数据统计。 Hadoop 《用通俗易懂的话说下hadoop是什么,能做什么》 《史上最详细的Hadoop环境搭建》 HDFS 《【Hadoop学习】HDFS基本原理》 MapReduce 《用通俗易懂的大白话讲解Map/Reduce原理》 《 简单的map-reduce的java例子》 Yarn 《初步掌握Yarn的架构及原理》 Spark 《Spark(一): 基本架构及原理》 安全web 安全XSS 《xss攻击原理与解决方法》CSRF 《CSRF原理及防范》 SQL 注入 《SQL注入》 Hash Dos 《邪恶的JAVA HASH DOS攻击》 利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。 《一种高级的DoS攻击-Hash碰撞攻击》 《关于Hash Collision DoS漏洞：解析与解决方案》 脚本注入 《上传文件漏洞原理及防范》 漏洞扫描工具 《DVWA》 W3af OpenVAS详解 验证码 《验证码原理分析及实现》 《详解滑动验证码的实现原理》 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。 《淘宝滑动验证码研究》 DDoS 防范 《学习手册：DDoS的攻击方式及防御手段》 《免费DDoS攻击测试工具大合集》 用户隐私信息保护 用户密码非明文保存，加动态salt。 身份证号，手机号如果要显示，用 “*” 替代部分字符。 联系方式在的显示与否由用户自己控制。 TODO 《个人隐私包括哪些》 《在互联网上，隐私的范围包括哪些？》 《用户密码保存》 序列化漏洞 《Lib之过？Java反序列化漏洞通用利用分析》 加密解密对称加密 《常见对称加密算法》 DES、3DES、Blowfish、AES DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。 DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。 哈希算法 《常用的哈希算法》 MD5 和 SHA-1 已经不再安全，已被弃用。 目前 SHA-256 是比较安全的。 《基于Hash摘要签名的公网URL签名验证设计方案》 非对称加密 《常见非对称加密算法》 RSA、DSA、ECDSA(螺旋曲线加密算法) 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。 《区块链的加密技术》 服务器安全 《Linux强化论：15步打造一个安全的Linux服务器》 数据安全数据备份TODO 网络隔离内外网分离TODO 登录跳板机在内外环境中通过跳板机登录到线上主机。 《搭建简易堡垒机》 授权、认证RBAC 《基于组织角色的权限设计》 《权限系统与RBAC模型概述》 《Spring整合Shiro做权限控制模块详细案例分析》 OAuth2.0 《理解OAuth 2.0》 《一张图搞定OAuth2.0》 双因素认证（2FA）2FA - Two-factor authentication，用于加强登录验证 常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key） 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html) 单点登录(SSO) 《单点登录原理与简单实现》 CAS单点登录框架 常用开源框架开源协议 《开源协议的选择》 如何选择一个开源软件协议 日志框架Log4j、Log4j2 《log4j 详细讲解》 《log4j2 实际使用详解》 《Log4j1,Logback以及Log4j2性能测试对比》 Log4J 异步日志性能优异。 Logback 《最全LogBack 详解、含java案例和配置说明》 ORM 《ORM框架使用优缺点》 主要目的是为了提高开发效率。 MyBatis： 《mybatis缓存机制详解》 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。 《MyBatis学习之代码生成器Generator》 网络框架TODO Web 框架Spring 家族Spring Spring 简明教程 Spring Boot 官方网站 《Spring Boot基础教程》 Spring Cloud Spring Boot 中文索引站 Spring Cloud 中文文档 《Spring Cloud基础教程》 工具框架 《Apache Commons 工具类介绍及简单使用》 《Google guava 中文教程》 分布式设计扩展性设计 《架构师不可不知的十大可扩展架构》 总结下来，通用的套路就是分布、缓存及异步处理。 《可扩展性设计之数据切分》 水平切分+垂直切分 利用中间件进行分片如，MySQL Proxy。 利用分片策略进行切分，如按照ID取模。 《说说如何实现可扩展性的大型网站架构》 分布式服务+消息队列。 《大型网站技术架构（七）–网站的可扩展性架构》 稳定性 &amp; 高可用 《系统设计：关于高可用系统的一些技术方案》 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。 自动化测试：通过完善的测试，减少发布引起的故障。 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。 《关于高可用的系统》 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。 硬件负载均衡 《转！！负载均衡器技术Nginx和F5的优缺点对比》 主要是和F5对比。 《软/硬件负载均衡产品 你知多少？》 软件负载均衡 《几种负载均衡算法》 轮寻、权重、负载、最少连接、QoS 《DNS负载均衡》 配置简单，更新速度慢。 《Nginx负载均衡》 简单轻量、学习成本低；主要适用于web应用。 《借助LVS+Keepalived实现负载均衡 》 配置比较负载、只支持到4层，性能较高。 《HAProxy用法详解 全网最详细中文文档》 支持到七层（比如HTTP）、功能比较全面，性能也不错。 《Haproxy+Keepalived+MySQL实现读均衡负载》 主要是用户读请求的负载均衡。 《rabbitmq+haproxy+keepalived实现高可用集群搭建》 限流 《谈谈高并发系统的限流》 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。 Nginx 限流：通过 limit_req 等模块限制并发连接数。 应用层容灾 《防雪崩利器：熔断器 Hystrix 的原理与使用》 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。 Hystrix设计原则： 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 《缓存穿透，缓存击穿，缓存雪崩解决方案分析》 《缓存击穿、失效以及热点key问题》 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期； 热点数据：热点数据单独存储；使用本地缓存；分成多个子key； 跨机房容灾 《“异地多活”多机房部署经验谈》 通过自研中间件进行数据同步。 《异地多活（异地双活）实践经验》 注意延迟问题，多次跨机房调用会将延时放大数倍。 建房间专线很大概率会出现问题，做好运维和程序层面的容错。 不能依赖于程序端数据双写，要有自动同步方案。 数据永不在高延迟和较差网络质量下，考虑同步质量问题。 核心业务和次要业务分而治之，甚至只考虑核心业务。 异地多活监控部署、测试也要跟上。 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。 控制跨机房消息体大小，越小越好。 考虑使用docker容器虚拟化技术，提高动态调度能力。 容灾技术及建设经验介绍 容灾演练流程 《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》 常见故障画像 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。 平滑启动 平滑重启应用思路1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用 《JVM安全退出（如何优雅的关闭java服务）》推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。 《常见Java应用如何优雅关闭》Java、Spring、Dubbo 优雅关闭方式。 数据库扩展读写分离模式 《Mysql主从方案的实现》 《搭建MySQL主从复制经典架构》 《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》 《DRBD+Heartbeat+Mysql高可用读写分离架构》 DRDB 进行磁盘复制，避免单点问题。 《MySQL Cluster 方式》 分片模式 《分库分表需要考虑的问题及方案》 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。 问题：事务、Join、迁移、扩容、ID、分页等。 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。 分库策略：数值范围；取模；日期等。 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 《MySql分表和表分区详解》 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。 分表：物理上创建不同的表、客户端需要管理分表路由。 服务治理服务注册与发现 《永不失联！如何实现微服务架构中的服务发现？》 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。 服务器端服务发现模式：客户端通过负载均衡查询服务实例。 《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》 CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap） 作者认为目前 Consul 对 Spring cloud 的支持比较好。 《基于Zookeeper的服务注册与发现》 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 服务路由控制 《分布式服务框架学习笔记4 服务路由》 原则：透明化路由 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接 本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。 配置方式：统一注册表；本地配置；动态下发。 分布式一致CAP 与 BASE 理论 《从分布式一致性谈到CAP理论、BASE理论》 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致) CAP：一致性、可用性、分区容错性(网络故障引起) BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性） BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 分布式锁 《分布式锁的几种实现方式》 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入； 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。 Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。 《基于Zookeeper的分布式锁》 清楚的原理描述 + Java 代码示例。 《jedisLock—redis分布式锁实现》 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。 《Memcached 和 Redis 分布式锁方案》 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。 分布式一致性算法PAXOS 《分布式系列文章——Paxos算法原理与推导》 《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》 《【分布式】Zookeeper与Paxos》 Zab 《Zab：Zookeeper 中的分布式一致性协议介绍》 Raft 《Raft 为什么是更易理解的分布式一致性算法》 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人） 通过随机等待的方式发出投票，得票多的获胜。 Gossip 《Gossip算法》 两阶段提交、多阶段提交 《关于分布式事务、两阶段提交协议、三阶提交协议》 幂等 《分布式系统—幂等性设计》 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 分布式一致方案 《分布式系统事务一致性解决方案》 《保证分布式系统数据一致性的6种方案》 分布式 Leader 节点选举 《利用zookeeper实现分布式leader节点选举》 TCC(Try/Confirm/Cancel) 柔性事务 《传统事务与柔性事务》 基于BASE理论：基本可用、柔性状态、最终一致。 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。 分布式文件系统 说说分布式文件存储系统-基本架构 ？ 《各种分布式文件系统的比较》 ？ HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。 FastDFS：轻量级、适合小文件。 唯一ID 生成全局唯一ID 《高并发分布式系统中生成全局唯一Id汇总》 Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器) Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” UUID：缺点，无序，字符串过长，占用空间，影响检索性能。 MongoDB 方案：利用 ObjectId。缺点：不能自增。 《TDDL 在分布式下的SEQUENCE原理》 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。 一致性Hash算法 《一致性哈希算法》 设计思想 &amp; 开发模式DDD(Domain-driven Design - 领域驱动设计) 《浅谈我对DDD领域驱动设计的理解》 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。 《领域驱动设计的基础知识总结》 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字； 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。 使用的模式： 关联尽量少，尽量单项，尽量降低整体复杂度。 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互； 工厂（Factory）：类似于设计模式中的工厂模式。 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。 《领域驱动设计(DDD)实现之路》 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。 《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》 命令查询职责分离(CQRS)CQRS — Command Query Responsibility Seperation 《领域驱动设计系列 (六)：CQRS》 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。 《DDD CQRS架构和传统架构的优缺点比较》 最终一致的设计理念；依赖于高可用消息中间件。 《CQRS架构简介》 一个实现 CQRS 的抽象案例。 《深度长文：我对CQRS/EventSourcing架构的思考》 CQRS 模式分析 + 12306 抢票案例 贫血，充血模型 《贫血，充血模型的解释以及一些经验》 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重； 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。 作者主张使用贫血模式。 Actor 模式TODO 响应式编程ReactorTODO RxJavaTODO Vert.xTODO DODAF2.0 《DODAF2.0方法论》 《DODAF2.0之能力视角如何落地》 Serverless无需过多关系服务器的服务架构理念。 《什么是Serverless无服务器架构？》 Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。 Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。 Serverless 不代表某个具体的框架。 《如何理解Serverless？》 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service） Service Mesh 《什么是Service Mesh？》 《初识 Service Mesh》 项目管理架构评审 《架构设计之如何评审架构设计说明书》 《人人都是架构师：非功能性需求》 重构 《架构之重构的12条军规》 代码规范 《阿里巴巴Java开发手册》 代码 Review制度还是制度!另外，每个公司需要根据自己的需求和目标制定自己的 check list 《为什么你做不好 Code Review？》 代码 review 做的好，在于制度建设。 《从零开始Code Review》 《Code Review Checklist》 《Java Code Review Checklist》 《如何用 gitlab 做 code review》 RUP 《运用RUP 4+1视图方法进行软件架构设计》 看板管理 《说说看板在项目中的应用》 SCRUMSCRUM - 争球 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图； 五个价值观：专注、勇气、公开、承诺、尊重。 《敏捷项目管理流程-Scrum框架最全总结！》 《敏捷其实很简单3—敏捷方法之scrum》 敏捷开发TODO 极限编程（XP）XP - eXtreme Programming 《主流敏捷开发方法：极限编程XP》 是一种指导开发人员的方法论。 4大价值： 沟通：鼓励口头沟通，提高效率。 简单：够用就好。 反馈：及时反馈、通知相关人。 勇气：提倡拥抱变化，敢于重构。 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。 结对编程边写码，边review。能够增强代码质量、减少bug。 《结对编程》 PDCA 循环质量管理P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进 《PDCA》 FMEA管理模式TODO 通用业务术语TODO 技术趋势TODO 政策、法规法律 《中华人民共和国网络安全法》 2016年11月7日发布，自2017年6月1日起施行 《个人信息保护法》 个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。 《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》 《解释》共十三条，自2017年6月1日起施行 1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”； 2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上； 3、对于其他公民个人信息，标准为 5000条以上。 《中华人民共和国电子商务法》 2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行 解读电子商务法（一）什么是电商 解读电子商务法（二）电商经营者 解读电子商务法（三）电商行为规范 解读电子商务法（四）电商的法律关系 解读电子商务法（外传）电商挣钱的秘密 解读电子商务法（外传）电商模式 程序员需要知道的法律常识 白话法律42讲-为程序员打造的专属法律武器 严格遵守刑法253法条我国刑法第253条之一规定： 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。 最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪” 《非法获取公民个人信息罪》 架构师素质 《架构师画像》 业务理解和抽象能力 NB的代码能力 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； 全局：是否考虑到了对上下游的系统的影响。 权衡：权衡投入产出比；优先级和节奏控制； 《关于架构优化和设计，架构师必须知道的事情》 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。 基础设施、配置、测试、开发、运维综合考虑。 考虑人、团队、和组织的影响。 《如何才能真正的提高自己，成为一名出色的架构师？》 《架构师的必备素质和成长途径》 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 《架构设计师—你在哪层楼？》 第一层的架构师看到的只是产品本身 第二层的架构师不仅看到自己的产品，还看到了整体的方案 第三层的架构师看到的是商业价值 团队管理TODO 招聘资讯行业资讯 36kr Techweb 公众号列表TODO 博客团队博客 阿里中间件博客 美团点评技术团队博客 个人博客 阮一峰的网络日志 酷壳 - COOLSHELL-陈皓 hellojava-阿里毕玄 Cm’s Blog 程序猿DD-翟永超-《Spring Cloud微服务实战》作者 综合门户、社区国内： CSDN 老牌技术社区、不必解释。 51cto.com ITeye 偏 Java 方向 博客园 ChinaUnix 偏 Linux 方向 开源中国社区 深度开源 伯乐在线 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。 ITPUB 腾讯云— 云+社区 阿里云— 云栖社区 IBM DeveloperWorks 开发者头条 LinkedKeeper 国外： DZone Reddit 问答、讨论类社区 segmentfault 问答+专栏 知乎 stackoverflow 行业数据分析 艾瑞网 QUEST MOBILE 国家数据 TalkingData 专项网站 测试: 领测国际 测试窝 TesterHome 运维: * [运维派](http://www.yunweipai.com/) * [Abcdocker](https://www.abcdocker.com/) Java: ImportNew 专注于 Java 技术分享 HowToDoInJava 英文博客 安全 红黑联盟 FreeBuf 大数据 中国大数据 其他专题网站： InfoQ 偏重于基础架构、运维方向 DockerInfo 专注于 Docker 应用及咨询、教程的网站 Linux公社 Linux 主题社区 其他类 程序员技能图谱 推荐参考书在线电子书 《深入理解Spring Cloud与微服务构建》 《阿里技术参考图册-研发篇》 《阿里技术参考图册-算法篇》 《2018美团点评技术年货（合辑）》70M InfoQ《架构师》月刊 《架构师之路》 纸质书更多架构方面书籍参考: awesome-java-books 开发方面 《阿里巴巴Java开发手册》详情 架构方面 《软件架构师的12项修炼：技术技能篇》详情 《架构之美》详情 《分布式服务架构》详情 《聊聊架构》 详情 《云原生应用架构实践》详情 《亿级流量网站架构核心技术》详情 《淘宝技术这十年》详情 《企业IT架构转型之道-中台战略思想与架构实战》 详情 《高可用架构（第1卷）》详情 技术管理方面 《CTO说》详情 《技术管理之巅》详情 《网易一千零一夜：互联网产品项目管理实战》详情 基础理论 《数学之美》详情 《编程珠玑》详情 工具方面TODO 大数据方面技术资源开源资源 github Apache 软件基金会 手册、文档、教程国内： W3Cschool Runoob.com HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。 Love2.io 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。 gitbook.cn 付费电子书。 ApacheCN AI、大数据方面系列中文文档。 国外： Quick Code 免费在线技术教程。 gitbook.com 有部分中文电子书。 Cheatography Cheat Sheets 大全，单页文档网站。 Tutorialspoint 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。 在线课堂 学徒无忧 极客时间 segmentfault 斯达克学院 牛客网 极客学院 51CTO学院 会议、活动 QCon ArchSummit GITC全球互联网技术大会 活动发布平台: 活动行 常用APP 极客时间 得到 找工作 Boss直聘 拉勾网 猎聘 100Offer 工具 极客搜索 技术文章搜索引擎。 代码托管 Coding 码云 文件服务 七牛 又拍云 综合云服务商 阿里云 腾讯云 百度云 新浪云 金山云 亚马逊云(AWS) 谷歌云 微软云 VPS Linode DigitalOcean Vultr]]></content>
  </entry>
  <entry>
    <title><![CDATA[【python3】利用百度搜索结果批量爬取邮箱地址]]></title>
    <url>%2F2019%2F05%2F30%2Fpython-crawl-baidu-email%2F</url>
    <content type="text"><![CDATA[准备工具 python3.6 pycharm 良好的网络 第三方库12345import requestsimport reimport eventletimport timefrom bs4 import BeautifulSoup requests： 用于网络请求 re： 正则表达式筛选邮箱 eventlet： 并发网络库 time： 产生随机延迟 BeautifulSoup： 解析网页文件 网络请求 请求头（headers） 123456789headers = &#123; &apos;USER_AGENTS&apos; : &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot; &quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot; &quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot; &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot; ... ... # 更多请求头可以百度获得&#125; 多个请求头防止封爬虫 请求页面 12345for a in [0,10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990]: url = &apos;http://www.baidu.com/s?wd=&quot;keywords&quot;&amp;pn=&apos;+str(a) web_data = requests.get(url,headers=headers).text soup = BeautifulSoup(web_data, &apos;lxml&apos;) titles = soup.select(&apos;div.result h3.t &gt; a &apos;) 获取搜索结果页面名及链接地址并记录 123456for title in titles: print(title.get_text(), title.get(&apos;href&apos;)) temp = title.get_text(), title.get(&apos;href&apos;) f = open(&apos;E:/test.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;) f.write(&apos;\n&apos;+&apos;\n&apos;+str(temp)) f.close() 访问记录下的网址并抓取邮箱地址 1234567891011121314151617try: eventlet.monkey_patch() with eventlet.Timeout(10, False): web_data2 = requests.get(title.get(&apos;href&apos;),verify=False) soup2 = BeautifulSoup(web_data2.text, &apos;lxml&apos;) regex = r&apos;([a-zA-Z0-9_.+-]+@[a-pr-zA-PRZ0-9-]+\.[a-zA-Z0-9-.]+)&apos; emails = re.findall(regex, str(soup2)) for email in emails: f = open(&apos;E:/test.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;) f.write(&apos;\n&apos;+str(email)) f.close()except: f = open(&apos;E:/test.txt&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;) f.close() 注意：这里正则式不抓取QQ邮箱 程序运行完毕后 即可在E盘根目录出现test.txt文件 里面存放着网页名称、网页链接、邮箱地址 关于我 国立华侨大学 软件工程大二在读 独立视频制作者 啥都感兴趣 联系方式： qq: 1093846898 wechat: czh-0526 e-mail: 1093846898@qq.com 觉得本文不错？请支持我]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装python3.6教程]]></title>
    <url>%2F2019%2F05%2F25%2Fpython-3-6-0-install%2F</url>
    <content type="text"><![CDATA[安装python3.6 安装依赖环境1$ yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 下载Python312下载地址 https://www.python.org/downloads/$ wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz 安装python3 我个人习惯安装在/usr/local/python3（具体安装位置看个人喜好） 创建目录： 1$ mkdir -p /usr/local/python3 解压下载好的Python-3.x.x.tgz包(具体包名因你下载的Python具体版本不不同⽽而不不同，如：我下载的是Python3.6.1.那我这里就是Python-3.6.1.tgz) 1$ tar -zxvf Python-3.6.1.tgz 进入解压后的目录，编译安装。 12$ cd Python-3.6.1$ ./configure --prefix=/usr/local/python3 make 1$ make make install 1$make install 建立python3的软链1$ ln -s /usr/local/python3/bin/python3 /usr/bin/python3 并将/usr/local/python3/bin加入PATH123456789$ vim ~/.bash_profile$ .bash_profile$ Get the aliases and functionsif [ -f ~/.bashrc ]; then. ~/.bashrcfi$ User specific environment and startup programsPATH=$PATH:$HOME/bin:/usr/local/python3/binexport PATH 按ESC，输入:wq回车退出。 修改完记得执行行下面的命令，让上一步的修改生效： 1$ source ~/.bash_profile 检查Python3及pip3是否正常可用： 1234$ python3 -VPython 3.6.1$ pip3 -Vpip 9.0.1 from /usr/local/python3/lib/python3.6/site-packages (python 3.6) 关于我 国立华侨大学 软件工程大二在读 独立视频制作者 啥都感兴趣 联系方式： qq: 1093846898 wechat: czh-0526 e-mail: 1093846898@qq.com 觉得本文不错？请支持我]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVAweb尝试 -- 写一个留言系统]]></title>
    <url>%2F2019%2F05%2F23%2Fjava-servlet-try%2F</url>
    <content type="text"><![CDATA[实现工具 IntelliJ IDEA tomcat 7.0 mysql 5.0 windows10 jdbc包：mysql-connector-java.jar 项目仓库地址: JAVAweb留言系统项目图 /src 存放java文件 /web 存放jsp文件 /web/WEB-INF 存放web.xml文件（划重点） /web/WEB-INF/classes 存放编译过后的java文件（自动生成） /web/WEB-INF/lib 存放第三方包文件 关于我 国立华侨大学 软件工程大二在读 独立视频制作者 啥都感兴趣 联系方式： qq: 1093846898 wechat: czh-0526 e-mail: 1093846898@qq.com 觉得本文不错？请支持我]]></content>
  </entry>
  <entry>
    <title><![CDATA[IOS系统卡死？safari-reaper类网页分析]]></title>
    <url>%2F2019%2F05%2F18%2Fios-to-shutdown%2F</url>
    <content type="text"><![CDATA[测试网站：https://monsterstars.github.io/safari-reaper (IOS系统慎点！！！！！)12monsterstars.github.io/safari-reaper长按可复制 发现 同学给我发了一个网站 引起了我的好奇这里就不放原网站了 复制网页后打开 发现并没有卡顿 问清楚只会在IOS系统上出现状况，立马用chrome模拟了一下IOS的safari浏览器 果然，问题出现了，我copy了一份代码放在自己的博客上，这里把关键代码拖出来分析 分析 在网站开头 即判断用户浏览器 12345&lt;script type=&quot;text/javascript&quot;&gt; if(!(/(iphone|ipad)/i).test(window.navigator.userAgent))&#123; window.location.href = &apos;/safari-reaper-android&apos;; &#125;&lt;/script&gt; 非Iphone/Ipad用户跳转到其他页面 将div标签设置成某个图片 12345678910&lt;style&gt;body &#123; background: repeat url(&apos;data:image/jpeg;base64,/9j/4AAQSkZ.........(这里省略了几千个字符吧)WFpg3/9k=&apos;);&#125;div &#123; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width:10000px; height:10000px;&#125;&lt;/style&gt; 其中这个图片的路径非常奇怪，抓取下来的图片大概长这样 初步猜测，可能是浏览器内部的数据？？？ onselectstart=”return false” 禁止鼠标选中文字，oncontextmenu=”return false” 在页面的Body范围内，当触发客户端的ContextMenu事件时，返回false值，使右键不能弹出。 1&lt;body oncontextmenu=&quot;return false&quot; onselectstart=&quot;return false&quot;&gt; 人心险恶啊。 正文部分就简单多了 都是div的嵌套 打开效果如图 关于我 国立华侨大学 软件工程大二在读 独立视频制作者 啥都感兴趣 联系方式： qq: 1093846898 wechat: czh-0526 e-mail: 1093846898@qq.com 觉得本文不错？请支持我]]></content>
  </entry>
  <entry>
    <title><![CDATA[超级酷炫！Atom编辑器插件 写代码写出飞一般的感觉]]></title>
    <url>%2F2019%2F05%2F17%2Fatom-activate-power-mode%2F</url>
    <content type="text"><![CDATA[如此酷炫的代码拓展，实现起来非常容易！ 安装环境：windows10， atom编辑器 安装Atom 下载网址：https://atom.io/ 根据提示安装Atom，默认情况安装在C:\Users\Administrator\AppData\Local\atom（每个人电脑路径有点不一样，找下就可以了）Atom安装成功后配置环境变量，桌面点击计算机右键-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量，找到path进行编辑，在最后添加；C:\Users\Administrator\AppData\Local\atom\bin安装activate-power-mode插件 github仓库地址：https://github.com/JoelBesada/activate-power-mode 同样可以在Atom编辑器扩展中下载安装（可能被墙） 这里只讲解第一种方法 第二种方法较为简单安装后即可使用 将下载下来的文件夹放在C:\Users\Administrator.atom\packages目录下打开cmd命令，输入cd C:\Users\Administrator.atom\packages\activate-power-mode(就是进入插件的根目录)回车，再输入apm install(该命令是因为之前配了环境变量才起作用)，等待出现 installing modules done 就成功了！重新启动atom编辑器（可在atom中ctrl + shift + f5刷新），然后使用快捷键ctrl + alt + o来对插件进行开启和关闭。详细配置 Combo Mode - Enabled 勾选后统计连击数 Combo Mode - Activation Threshold 超过此连击数后统计效果 Combo Mode - Exclamation Every 每到此值的倍数后显示连击特效 Combo Mode - Exclamation Texts 显示连击特效时随机出现的文字，用逗号隔开，默认值为【Super!, Radical!, Fantastic!, Great!, OMG, Whoah!, :O, Nice!, Splendid!, Wild!, Grand!, Impressive!, Stupendous!, Extreme!, Awesome!】 Combo Mode - Opacity 连击数透明度 Combo Mode - Streak Timeout 超过设定的秒数后，重新统计连击数 Excluded File Types 只作用于指定扩展名的文件，默认值为.即所有文件，设置规则为填写文件的扩展名，如有多个扩展名可用逗号隔开 Particles - Enabled 勾选后达到指定连击数后在光标处显示颗粒 Particles Colours 颗粒颜色，有三种设置 –Particles will be the color at the cursor 颗粒颜色与当前光标所在字的颜色一致–Particles will have random colours 颗粒颜色随机–Particles will have a fixed colour 颗粒颜色为指定颜色（可配置） Play Audio - Enabled 勾选后达到指定连击数后每次按键播放音效 Play Audio - Volumn 音效音量 Screen Shake - Enabled 勾选后达到指定连击数后振动编辑区域]]></content>
  </entry>
  <entry>
    <title><![CDATA[javascript学习笔记（持续更新）]]></title>
    <url>%2F2019%2F05%2F14%2Fjavascript-learning%2F</url>
    <content type="text"><![CDATA[JavaScript简介JavaScript：写入 HTML 输出1234&lt;p&gt;JavaScript 能够直接写入 HTML 输出流中：&lt;/p&gt;&lt;script&gt;document.write(&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;);document.write(&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;);&lt;/script&gt; 123&lt;p&gt;您只能在 HTML 输出流中使用 &lt;strong&gt;document.write&lt;/strong&gt;。 如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。&lt;/p&gt; JavaScript：对事件作出反应1&lt;button type=&quot;button&quot; onclick=&quot;alert(&apos;Welcome!&apos;)&quot;&gt;点击这里&lt;/button&gt; JavaScript：改变 HTML 内容12345678910&lt;p id=&quot;demo&quot;&gt;JavaScript 能改变 HTML 元素的内容。&lt;/p&gt;&lt;script&gt;function myFunction()&#123;x=document.getElementById(&quot;demo&quot;); // 找到元素x.innerHTML=&quot;Hello JavaScript!&quot;; // 改变内容&#125;&lt;/script&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt; JavaScript：改变 HTML 图像123456789101112131415&lt;script&gt;function changeImage()&#123;element=document.getElementById(&apos;myimage&apos;)if (element.src.match(&quot;bulbon&quot;)) &#123; element.src=&quot;/i/eg_bulboff.gif&quot;; &#125;else &#123; element.src=&quot;/i/eg_bulbon.gif&quot;; &#125;&#125;&lt;/script&gt;&lt;img id=&quot;myimage&quot; onclick=&quot;changeImage()&quot; src=&quot;/i/eg_bulboff.gif&quot;&gt; JavaScript：改变 HTML 样式12345678910&lt;p id=&quot;demo&quot;&gt;JavaScript 能改变 HTML 元素的样式。&lt;/p&gt;&lt;script&gt;function myFunction()&#123;x=document.getElementById(&quot;demo&quot;) // 找到元素x.style.color=&quot;#ff0000&quot;; // 改变样式&#125;&lt;/script&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt; JavaScript：验证输入12345678910111213&lt;p&gt;请输入数字。如果输入值不是数字，浏览器会弹出提示框。&lt;/p&gt;&lt;input id=&quot;demo&quot; type=&quot;text&quot;&gt;&lt;script&gt;function myFunction()&#123;var x=document.getElementById(&quot;demo&quot;).value;if(x==&quot;&quot;||isNaN(x)) //isNaN(x):x为数字为假，x不为数字为真 &#123;alert(&quot;Not Numeric&quot;); &#125;&#125;&lt;/script&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt; JavaScript 使用HTML 中的脚本必须位于 与 标签之间。12&lt;script&gt;alert(&quot;My First JavaScript&quot;);&lt;/script&gt; 脚本可被放置在 HTML 页面的 和 部分中。JavaScript 函数和事件 或 中的 JavaScript 您可以在 HTML 文档中放入不限数量的脚本。 脚本可位于 HTML 的 或 部分中，或者同时存在于两个部分中。通常的做法是把函数放入 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。 中的 JavaScript 函数12345678910111213&lt;head&gt;&lt;script&gt;function myFunction()&#123;document.getElementById(&quot;demo&quot;).innerHTML=&quot;My First JavaScript Function&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My Web Page&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;A Paragraph.&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;&lt;/body&gt; 中的 JavaScript 函数1234567891011&lt;body&gt;&lt;h1&gt;My First Web Page&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;A Paragraph.&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;&lt;script&gt;function myFunction()&#123;document.getElementById(&quot;demo&quot;).innerHTML=&quot;My First JavaScript Function&quot;;&#125;&lt;/script&gt;&lt;/body&gt; 外部的 JavaScript123&lt;body&gt;&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; JavaScript 输出操作 HTML 元素1234&lt;p id=&quot;demo&quot;&gt;My First Paragraph.&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML=&quot;My First JavaScript&quot;;&lt;/script&gt; 写到文档输出123456&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;script&gt;document.write(&quot;&lt;p&gt;我的第一段 JavaScript&lt;/p&gt;&quot;);&lt;/script&gt;&lt;/body&gt; JavaScript 语句JavaScript 代码JavaScript 代码块 JavaScript 语句通过代码块的形式进行组合。 块由左花括号开始，由右花括号结束。 块的作用是使语句序列一起执行。 123456789101112&lt;p id=&quot;myPar&quot;&gt;I am a paragraph.&lt;/p&gt;&lt;div id=&quot;myDiv&quot;&gt;I am a div.&lt;/div&gt;&lt;p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;&lt;/p&gt;&lt;script&gt;function myFunction()&#123;document.getElementById(&quot;myPar&quot;).innerHTML=&quot;Hello World&quot;;document.getElementById(&quot;myDiv&quot;).innerHTML=&quot;How are you?&quot;;&#125;&lt;/script&gt; JavaScript 对大小写敏感。JavaScript 会忽略多余的空格。JavaScript 注释JavaScript 注释 单行注释以 // 开头。 JavaScript 多行注释 多行注释以 \/ 开始，以 \/ 结尾。 使用注释来阻止执行(测试代码)在行末使用注释JavaScript 变量JavaScript 变量 与代数一样，JavaScript 变量可用于存放值（比如 x=2）和表达式（比如 z=x+y）。 JavaScript 数据类型 JavaScript 变量有很多种类型，但是现在，我们只关注数字和字符串。 当您向变量分配文本值时，应该用双引号或单引号包围这个值。 当您向变量赋的值是数值时，不要使用引号。如果您用引号包围数值，该值会被作为文本来处理。 声明（创建） JavaScript 变量12345678910&lt;p&gt;点击这里来创建变量，并显示结果。&lt;/p&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction()&#123;var carname=&quot;Volvo&quot;;document.getElementById(&quot;demo&quot;).innerHTML=carname;&#125;&lt;/script&gt; 一条语句，多个变量 您可以在一条语句中声明很多变量。该语句以 var 开头，并使用逗号分隔变量即可. 声明也可横跨多行. Value = undefined重新声明 JavaScript 变量JavaScript 算数JavaScript 数据类型(字符串、数字、布尔、数组、对象、Null、Undefined)JavaScript 拥有动态类型 JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型：12345&lt;script&gt;var x // x 为 undefinedvar x = 6; // x 为数字var x = &quot;Bill&quot;; // x 为字符串&lt;/script&gt; JavaScript 字符串 字符串是存储字符（比如 “Bill Gates”）的变量。 字符串可以是引号中的任意文本。您可以使用单引号或双引号： 您可以在字符串中使用引号，只要不匹配包围字符串的引号即可：1234567891011121314&lt;script&gt;var carname1=&quot;Bill Gates&quot;;var carname2=&apos;Bill Gates&apos;;var answer1=&quot;Nice to meet you!&quot;;var answer2=&quot;He is called &apos;Bill&apos;&quot;;var answer3=&apos;He is called &quot;Bill&quot;&apos;;document.write(carname1 + &quot;&lt;br&gt;&quot;)document.write(carname2 + &quot;&lt;br&gt;&quot;)document.write(answer1 + &quot;&lt;br&gt;&quot;)document.write(answer2 + &quot;&lt;br&gt;&quot;)document.write(answer3 + &quot;&lt;br&gt;&quot;)&lt;/script&gt; JavaScript 数字 JavaScript 只有一种数字类型。 数字可以带小数点，也可以不带。 极大或极小的数字可以通过科学（指数）计数法来书写：123456789101112&lt;script&gt;var x1=36.00;var x2=36;var y=123e5;var z=123e-5;document.write(x1 + &quot;&lt;br&gt;&quot;)document.write(x2 + &quot;&lt;br&gt;&quot;)document.write(y + &quot;&lt;br&gt;&quot;)document.write(z + &quot;&lt;br&gt;&quot;)&lt;/script&gt; JavaScript 布尔 布尔（逻辑）只能有两个值：true 或 false。 JavaScript 数组 三种创建数组方式：12345678910111213141516&lt;script&gt;var cars=new Array();cars[0]=&quot;Audi&quot;;cars[1]=&quot;BMW&quot;;cars[2]=&quot;Volvo&quot;;&lt;/script&gt;&lt;script&gt;var cars=new Array(&quot;Audi&quot;,&quot;BMW&quot;,&quot;Volvo&quot;);&lt;/script&gt;&lt;script&gt;var cars=[&quot;Audi&quot;,&quot;BMW&quot;,&quot;Volvo&quot;];&lt;/script&gt; JavaScript 对象 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔。声明可以跨行。 123&lt;script&gt;var person=&#123;firstname:&quot;Bill&quot;, lastname:&quot;Gates&quot;, id:5566&#125;;&lt;/script&gt; 对象属性有两种寻址方式。 1234&lt;script&gt;name=person.lastname;name=person[&quot;lastname&quot;];&lt;/script&gt; Undefined 和 Null Undefined 这个值表示变量不含有值。 //不含有值，没有定义过。 可以通过将变量的值设置为 null 来清空变量。 //值为null 声明变量类型 当您声明新变量时，可以使用关键词 “new” 来声明其类型。声明类型后的变量不能赋其他类型变量的值。1234567&lt;script&gt;var carname=new String;var x= new Number;var y= new Boolean;var cars= new Array;var person= new Object;&lt;/script&gt; JavaScript 对象 JavaScript 中的所有事物都是对象：字符串、数字、数组、日期，等等。 在 JavaScript 中，对象是拥有属性和方法的数据。 属性和方法JavaScript 中的对象 在 JavaScript 中，对象是数据（变量），拥有属性和方法。 当您像这样声明一个 JavaScript 变量时： 1&lt;script&gt;var txt = &quot;Hello&quot;;&lt;/script&gt; 您实际上已经创建了一个 JavaScript 字符串对象。字符串对象拥有内建的属性 length。对于上面的字符串来说，length 的值是 5。字符串对象同时拥有若干个内建的方法。 属性： 123&lt;script&gt;txt.length=5&lt;/script&gt; 方法： 12345&lt;script&gt;txt.indexOf()txt.replace()txt.search()&lt;/script&gt; 创建 JavaScript 对象12345678&lt;script&gt;person=new Object();person.firstname=&quot;Bill&quot;;person.lastname=&quot;Gates&quot;;person.age=56;person.eyecolor=&quot;blue&quot;;document.write(person.firstname + &quot; is &quot; + person.age + &quot; years old.&quot;);&lt;/script&gt; 访问对象的属性语法：objectName.propertyName1234&lt;script&gt;var message=&quot;Hello World!&quot;;var x=message.length;&lt;/script&gt; 访问对象的方法语法：objectName.methodName()1234&lt;script&gt;var message=&quot;Hello world!&quot;;var x=message.toUpperCase();&lt;/script&gt; JavaScript 函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。1234567891011&lt;head&gt;&lt;script&gt;function myFunction()&#123;alert(&quot;Hello World!&quot;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;&lt;/body&gt; JavaScript 函数语法 函数就是包裹在花括号中的代码块，前面使用了关键词 function： 1234function functionname()&#123;这里是要执行的代码&#125; 当调用该函数时，会执行函数内的代码。 可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。 JavaScript 对大小写敏感。关键词 function 必须是小写的，并且必须以与函数名称相同的大小写来调用函数。 调用带参数的函数 在调用函数时，您可以向其传递值，这些值被称为参数。这些参数可以在函数中使用。您可以发送任意多的参数，由逗号 (,) 分隔。12345678&lt;p&gt;点击这个按钮，来调用带参数的函数。&lt;/p&gt;&lt;button onclick=&quot;myFunction(&apos;Bill Gates&apos;,&apos;CEO&apos;)&quot;&gt;点击这里&lt;/button&gt;&lt;script&gt;function myFunction(name,job)&#123;alert(&quot;Welcome &quot; + name + &quot;, the &quot; + job);&#125;&lt;/script&gt; 带有返回值的函数123456789&lt;p&gt;本例调用的函数会执行一个计算，然后返回结果：&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction(a,b)&#123;return a*b;&#125;document.getElementById(&quot;demo&quot;).innerHTML=myFunction(4,3);&lt;/script&gt; 在您仅仅希望退出函数时 ，也可使用 return 语句。返回值是可选的：12345678910&lt;script&gt;function myFunction(a,b)&#123;if (a&gt;b) &#123; return; &#125;x=a+b&#125;&lt;/script&gt; 局部 JavaScript 变量 在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。 您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。 只要函数运行完毕，本地变量就会被删除。 全局 JavaScript 变量 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 JavaScript 变量的生存期 JavaScript 变量的生命期从它们被声明的时间开始。 局部变量会在函数运行以后被删除。 全局变量会在页面关闭后被删除。 向未声明的 JavaScript 变量来分配值 如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。 这条语句： 1&lt;script&gt;carname=&quot;Volvo&quot;;&lt;/script&gt; 将声明一个全局变量 carname，即使它在函数内执行。 JavaScript 运算符JavaScript 比较和逻辑运算符JavaScript If…Else 语句JavaScript Switch 语句JavaScript For 循环JavaScript While 循环JavaScript Break 和 Continue 语句break 语句用于跳出循环。continue 用于跳过循环中的一个迭代。 JavaScript 错误 - Throw、Try 和 Catch try 语句测试代码块的错误。 catch 语句处理错误。 throw 语句创建自定义错误。 JavaScript 测试和捕捉 try 语句允许我们定义在执行时进行错误测试的代码块。 catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。 JavaScript 语句 try 和 catch 是成对出现的。 语法： 12345678try &#123; //在这里运行代码 &#125;catch(err) &#123; //在这里处理错误 &#125; 实例： 12345678910111213141516171819202122&lt;head&gt;&lt;script&gt;var txt=&quot;&quot;;function message()&#123;try &#123; adddlert(&quot;Welcome guest!&quot;); //错误在于alert打错 &#125;catch(err) &#123; txt=&quot;本页有一个错误。\n\n&quot;; txt+=&quot;错误描述：&quot; + err.message + &quot;\n\n&quot;; txt+=&quot;点击确定继续。\n\n&quot;; alert(txt); &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;查看消息&quot; onclick=&quot;message()&quot; /&gt;&lt;/body&gt; Throw 语句 throw 语句允许我们创建自定义错误。 正确的技术术语是：创建或抛出异常（exception）。 如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息。 语法： 1throw exception 异常可以是 JavaScript 字符串、数字、逻辑值或对象。 12345678910111213141516171819202122232425&lt;body&gt;&lt;script&gt;function myFunction()&#123;try&#123;var x=document.getElementById(&quot;demo&quot;).value;if(x==&quot;&quot;) throw &quot;值为空&quot;;if(isNaN(x)) throw &quot;不是数字&quot;;if(x&gt;10) throw &quot;太大&quot;;if(x&lt;5) throw &quot;太小&quot;;&#125;catch(err)&#123;var y=document.getElementById(&quot;mess&quot;);y.innerHTML=&quot;错误：&quot; + err + &quot;。&quot;;&#125;&#125;&lt;/script&gt;&lt;h1&gt;我的第一个 JavaScript 程序&lt;/h1&gt;&lt;p&gt;请输入 5 到 10 之间的数字：&lt;/p&gt;&lt;input id=&quot;demo&quot; type=&quot;text&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;测试输入值&lt;/button&gt;&lt;p id=&quot;mess&quot;&gt;&lt;/p&gt;&lt;/body&gt; JavaScript 表单验证关于我 国立华侨大学 软件工程大二在读 独立视频制作者 啥都感兴趣 联系方式： qq: 1093846898 wechat: czh-0526 e-mail: 1093846898@qq.com 觉得本文不错？请支持我]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用Python爬虫爬取豆瓣某标签下的所有书籍信息]]></title>
    <url>%2F2019%2F05%2F13%2Fpython-crawler-douban%2F</url>
    <content type="text"><![CDATA[开发环境 Python 3.6编译器 PyCharm 网络请求123456import requestsfor tag in [&apos;%E8%AE%A1%E7%AE%97%E6%9C%BA&apos;, &apos;%e5%b0%8f%e8%af%b4&apos;]: #any tags你想搜索的任意标签名 for a in [0, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 220, 240, 260, 280, 300, 320, 340, 360, 380, 400, 420, 440,460, 480, 500, 520, 540, 560, 580, 600, 620, 640, 660, 680, 700, 720, 740, 760, 780, 800, 820, 840, 860,880, 900, 920, 940, 960, 980]: url = &apos;https://book.douban.com/tag/&apos;+tag+&apos;?start=&apos;+str(a) web_data = requests.get(url) requests库用于网络请求 用requests的get方法访问网站获得网页数据。 tag使用的是中文标签在URL编码转换后。 第四行代码可以简写 当时年少无知不懂写。 web_data用来存放返回数据。 解析数据123from bs4 import BeautifulSoupsoup = BeautifulSoup(web_data.text,&apos;lxml&apos;) titles = soup.select(&apos;#subject_list &gt; ul &gt; li &gt; div.info &gt; h2 &gt; a&apos;) 这里我使用了一个强大的第三方库 BeautifulSoup。 lxml用来进行文件格式解析，同样也是强大的库，用于是html格式更加完整。 web_data记得使用text方法获得内容，否则只会得到200提示。 soup.select方法有多种使用方法，这里只是以网页内在结构提取数据，其他方法还有通过class抓取。 打印结果12for title in titles: print(title.get_text(),title.get(&apos;href&apos;)) 循环游历数组，打印出每一个数据。 这里只打印出书名和书籍链接，需要其他信息，可以自行修改。 关于我 国立华侨大学 软件工程大二在读 独立视频制作者 啥都感兴趣 联系方式： qq: 1093846898 wechat: czh-0526 e-mail: 1093846898@qq.com 觉得本文不错？请支持我]]></content>
  </entry>
  <entry>
    <title><![CDATA[华侨大学宿舍区使用路由器完美教程]]></title>
    <url>%2F2019%2F05%2F12%2Fhqu-wifi%2F</url>
    <content type="text"><![CDATA[准备工作 路由器一台 网线若干 突破学校限制的动力 HQU绑定运营商登陆HQU 电脑连接到墙上的网线接口，浏览器中输入sam.hqu.edu.cn。 输入自己的学号、密码，登陆HQU，点击运营商绑定。 选择自己的运营商，找我买卡的选择的是厦门电信，其他运营商也类似，这里只以厦门电信作为说明。 输入自己的厦门电信手机号、密码。（不知道自己手机密码的尝试发送kw到10000查询密码。） 绑定成功后，断开网线。 路由器复制电脑MAC地址注意此部分 任何设备不要连接上墙上的网线接口 路由器通电，电脑连接上路由器，按照路由器说明说进入管理员页面。 各个路由器界面大同小异 本文介绍一例 其他路由器界面均大同小异 路由器功能选择MAC地址复制，将电脑的MAC地址复制进路由器中。 路由器拨号设置 路由器选择拨号上网。 账号输入 12学号@xmdx例如：1825120000@xmdx 密码输入(图片这里错误了应该是连接校园网的密码) 1连接校园网的密码 点击连接后 可以看到路由器连接成功。 测速后可以下载可以达到90M 上传8M 左右。 更多功能 访客网络 流量限速 刷梅林固件 ShadowsocksR/Shadowsocks 安装实现科学上网 … 更多功能可以自己探索 关于我 国立华侨大学 软件工程大二在读 独立视频制作者 啥都感兴趣 联系方式： qq: 1093846898 wechat: czh-0526 e-mail: 1093846898@qq.com 觉得本文不错？请支持我]]></content>
  </entry>
  <entry>
    <title><![CDATA[史上最完整教程！Hexo + GitHub page免费搭建个人博客]]></title>
    <url>%2F2019%2F05%2F11%2Fhexo-github-build-blog%2F</url>
    <content type="text"><![CDATA[使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； … 准备工作 GitHub Node.js Git-Bash Hexo 学习的激情 GitHub新建仓库 登陆GitHub Page 新建git仓库 新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是username，那么你就新建username.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://username.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 windows10下Node.js安装 登陆Node.js官网下载对应版本安装文件 环境变量检测 1$ node --version windows10下Git-Bash安装及SSH Key配置 登陆Git官网下载对应版本安装文件 安装完成后打开文件目录找到Git-Bash.exe并执行 配置Git用户及邮箱（在你的github上显示出来的提交者） 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; SSH Key配置 使用SSH Key 由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以必须要让github仓库认证你SSH key，在此之前，必须要生成SSH key。 配置SSH Key 1$ ssh-keygen -t rsa -C &quot;email@example.com&quot; 密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。这里使用的是rsa。 同时在密钥中有一个注释字段，用-C来指定所指定的注释，可以方便用户标识这个密钥，指出密钥的用途或其他有用的信息。所以在这里输入自己的邮箱或者其他都行。 输入完毕后程序同时要求输入一个密语字符串(passphrase)，空表示没有密语。接着会让输入2次口令(password)，空表示没有口令。3次回车即可完成当前步骤，此时[c盘&gt;用户&gt;自己的用户名&gt;.ssh]目录下已经生成好了。 将公钥上传到Github 登录github。打开setting-&gt;SSH keys，点击右上角 New SSH key，把生成好的公钥id_rsa.pub放进 key输入框中，再为当前的key起一个title来区分每个key。 Hexo克隆到本地并安装 在自己认为合适的地方新建一个文件夹 并执行Hexo安装 1$ npm install -g hexo-cli 检查hexo是否安装成功 1$ hexo -v 初始化文件夹 1$ hexo init 安装所需要的组件 1$ npm install 生成静态文件 1$ hexo g 实时预览 1$ hexo s 在浏览器中输入localhost:4000看到页面即为Hexo安装成功 使用Hexo写博客Hexo简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo原理 由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 Hexo初始化12$ hexo g //生成静态文件$ hexo s //启动本地服务 站点_config.yml配置特别注意 _config.yml文件中冒号后均有一个空格 基本描述 title 中填写博客名称 description 中填写博客描述 author 中填写作者 lauguage 中填写zh-CH（简体中文） timezone 中填写时区 Asia/Shanghai（亚洲上海） 生成路径 url 中填写github page地址 root 中填写网站根目录（即为/） permalink 中填写生成网站文件目录 修改为 1:title/ permalink_defaults 保持默认 文章的source路径手动创建年/月/日文件夹 注意 MarkDown中引用外部图片无法显示请开启此项 修改post_asset_folder为true 提交到GitHub deploy中 type 中填写git repository 填写github仓库地址 branch 填写提交分支 一般而言是master 执行命令后 即可自动生成静态文件并提交到github仓库 1$ hexo d -g 若报错 尝试运行后再尝试 1$ npm install hexo-deployer-git --save 至此 等待10-30分钟 就可以访问 username.github.io 访问自己的博客了 若想美化自己的博客可以继续往下看 否则直接跳转到2.8 Hexo修改主题 默认主题很丑，那我们就来换一个主题吧 我使用的主题是NexT 安装方法 12$ cd /你的Hexo文件夹路径/hexo/$ git clone https://github.com/iissnan/hexo-theme-next themes/next 打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 主题_config.yml配置 我开启的只有主页（Home）、归档（Archives）、关于我（About）三个页面 并开启图片（icons: true） 自定义背景静态图片背景 themes/next/source/css/_coutom/costom.styl 文件中添加 123456//背景body&#123; background-image:url(/images/backGround.jpg); background-repeat: no-repeat; background-attachment:fixed;&#125; 其中backGround.jpg存放在theme/next/source/images/文件夹中 动态图片背景 同理 在任意一个js文件中添加 12&lt;!-- 动态背景 --&gt;&lt;script type=&quot;text/javascript&quot; color=&quot;0,0,0&quot; opacity=&apos;0.5&apos; zIndex=&quot;-2&quot; count=&quot;70&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 其中 颜色我使用的是黑色（0，0，0），透明度：0.5；线段的数量是70；层数设定为-2。 第三方拓展站内搜索 安装hexo-generator-search 1$ npm install hexo-generator-search --save 打开站点配置文件_config.yml 添加 12345search: path: search.xml field: post format: html limit: 10000 我博客还没有太多文章就没有加搜索功能添加到首页上 如果需要 搜索结果保存在首页/search.xml文件中 搜索功能效果参考 留言板 一般采用第三方服务 有兴趣的可以自己搜索来使用 字数统计 参考hexo字数统计 阅读时间 浏览量统计 参考hexo访客统计 用MarkDown语法写博客编辑器 我是用的是Atom编辑器 普通的文本编辑器都可以胜任Hexo的编辑 MarkDown语法简介 参考MarkDown中文文档 首页不显示博文所有内容 MarkDown文件中添加一行1&lt;!--more--&gt; 最终效果 Monster的个人博客 更多Hexo博客 LEAFERx DOUBLEMINE uchuhimo 新樂街口的三角窗 关于我 国立华侨大学 软件工程大二在读 独立视频制作者 啥都感兴趣 联系方式： qq: 1093846898 wechat: czh-0526 e-mail: 1093846898@qq.com 觉得本文不错？请支持我]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法说明 (简体中文版)]]></title>
    <url>%2F2019%2F05%2F10%2Fmarkdown-syntax%2F</url>
    <content type="text"><![CDATA[NOTE: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to Markdown: Syntax. 声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里查看它的源文件。「繁体中文版的原始文件可以查看这里 。」–By @riku 注： 本项目托管于 GitHub上，请通过”派生”和”合并请求”来帮忙改进本项目。 Markdown 语法说明 (简体中文版) / (点击查看快速入门) 概述 宗旨 兼容 HTML 特殊字符自动转换 区块元素 段落和换行 标题 区块引用 列表 代码区块 分隔线 区段元素 链接 强调 代码 图片 其它 反斜杠 自动链接 感谢 Markdown 免费编辑器 概述 宗旨 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTML Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 这是一个普通段落。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转换写为： http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写： &amp;copy; Markdown 会保留它不动。而若你写： AT&amp;T Markdown 就会将它转为： AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 4 &lt; 5 Markdown 将会把它转换为： 4 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 ------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： # 这是 H1 ## 这是 H2 ###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ###### 区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： &gt; ## 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： * Red * Green * Blue 等同于： + Red + Green + Blue 也等同于： - Red - Green - Blue 有序列表则使用数字接着一个英文句点： 1. Bird 2. McHale 3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： &lt;ol&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;McHale&lt;/li&gt; &lt;li&gt;Parish&lt;/li&gt; &lt;/ol&gt; 如果你的列表标记写成： 1. Bird 1. McHale 1. Parish 或甚至是： 3. Bird 1. McHale 8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt;标签包起来，举例来说： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;Magic&lt;/li&gt; &lt;/ul&gt; 但是这个： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： * This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： * 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 1986\. What a great season. 代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： &lt;p&gt;Here is an example of AppleScript:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beep end tell &lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为： &lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation &amp;lt;/div&amp;gt; &lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 区段元素 链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. 会产生： &lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt; an example&lt;/a&gt; inline link.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用尖括号包起来： [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： *single asterisks* _single underscores_ **double asterisks** __double underscores__ 会转成： &lt;em&gt;single asterisks&lt;/em&gt; &lt;em&gt;single underscores&lt;/em&gt; &lt;strong&gt;double asterisks&lt;/strong&gt; &lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \*this text is surrounded by literal asterisks\* 代码 如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： Use the `printf()` function. 会产生： &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： ``There is a literal backtick (`) here.`` 这段语法会产生： &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生： &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don&apos;t use any `&lt;blink&gt;` tags. 转为： &lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生： &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 其它 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;http://example.com/&gt; Markdown 会转为： &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &lt;address@example.com&gt; Markdown 会转成： &lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65; &amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111; &amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61; &amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠： \*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 感谢 感谢 leafy7382 协助翻译，hlb、Randylien 帮忙润稿，ethantw 的汉字标准格式・CSS Reset， WM 回报文字错误。 感谢 fenprace，addv。 Markdown 免费编辑器 Windows 平台 MarkdownPad MarkPad Linux 平台 ReText Mac 平台 Mou 在线编辑器 Markable.in Dillinger.io 浏览器插件 MaDe (Chrome) 高级应用 Sublime Text 2 + MarkdownEditing / 教程 *** 如有更好的 Markdown 免费编辑器推荐，请到这里反馈，谢谢！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown Basics （快速入门）]]></title>
    <url>%2F2019%2F05%2F09%2Fmarkdown-basics%2F</url>
    <content type="text"><![CDATA[声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里查看它的源文件。「繁体中文版的原始文件可以查看这里」–By @riku 注： 本项目托管于 GitHub上，请通过”派生”和”合并请求”来帮忙改进本项目。 Markdown: Basics （快速入门） / (点击查看完整语法说明)Getting the Gist of Markdown’s Formatting Syntax此页提供了 Markdown 的简单概念， 语法说明 页提供了完整详细的文档，说明了每项功能。但是 Markdown 其实很简单就可以上手，此页文档提供了一些范例，并且每个范例都会提供输出的 HTML 结果。 其实直接试试看也是一个很不错的方法， Dingus 是一个网页应用程序，你可以把自已编写的 Markdown 文档转成 XHTML。 段落、标题、区块代码一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。 Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 区块引用则使用 email 形式的 ‘&gt;‘ 角括号。 Markdown 语法: A First Level Header ==================== A Second Level Header --------------------- Now is the time for all good men to come to the aid of their country. This is just a regular paragraph. The quick brown fox jumped over the lazy dog&apos;s back. ### Header 3 &gt; This is a blockquote. &gt; &gt; This is the second paragraph in the blockquote. &gt; &gt; ## This is an H2 in a blockquote 输出 HTML 为： &lt;h1&gt;A First Level Header&lt;/h1&gt; &lt;h2&gt;A Second Level Header&lt;/h2&gt; &lt;p&gt;Now is the time for all good men to come to the aid of their country. This is just a regular paragraph.&lt;/p&gt; &lt;p&gt;The quick brown fox jumped over the lazy dog&apos;s back.&lt;/p&gt; &lt;h3&gt;Header 3&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;This is a blockquote.&lt;/p&gt; &lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt; &lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt; &lt;/blockquote&gt; 修辞和强调Markdown 使用星号和底线来标记需要强调的区段。 Markdown 语法: Some of these words *are emphasized*. Some of these words _are emphasized also_. Use two asterisks for **strong emphasis**. Or, if you prefer, __use two underscores instead__. 输出 HTML 为: &lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;. Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;. Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt; 列表无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号： * Candy. * Gum. * Booze. 加号： + Candy. + Gum. + Booze. 和减号 - Candy. - Gum. - Booze. 都会输出 HTML 为： &lt;ul&gt; &lt;li&gt;Candy.&lt;/li&gt; &lt;li&gt;Gum.&lt;/li&gt; &lt;li&gt;Booze.&lt;/li&gt; &lt;/ul&gt; 有序的列表则是使用一般的数字接着一个英文句点作为项目标记： 1. Red 2. Green 3. Blue 输出 HTML 为： &lt;ol&gt; &lt;li&gt;Red&lt;/li&gt; &lt;li&gt;Green&lt;/li&gt; &lt;li&gt;Blue&lt;/li&gt; &lt;/ol&gt; 如果你在项目之间插入空行，那项目的内容会用 &lt;p&gt; 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。 * A list item. With multiple paragraphs. * Another item in the list. 输出 HTML 为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;A list item.&lt;/p&gt; &lt;p&gt;With multiple paragraphs.&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Another item in the list.&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 链接Markdown 支援两种形式的链接语法： 行内 和 参考 两种形式，两种都是使用角括号来把文字转成连结。 行内形式是直接在后面用括号直接接上链接： This is an [example link](http://example.com/). 输出 HTML 为： &lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot;&gt; example link&lt;/a&gt;.&lt;/p&gt; 你也可以选择性的加上 title 属性： This is an [example link](http://example.com/ &quot;With a Title&quot;). 输出 HTML 为： &lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&gt; example link&lt;/a&gt;.&lt;/p&gt; 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容： I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 输出 HTML 为： &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写： I start my morning with a cup of coffee and [The New York Times][NY Times]. [ny times]: http://www.nytimes.com/ 输出 HTML 为： &lt;p&gt;I start my morning with a cup of coffee and &lt;a href=&quot;http://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt; 图片图片的语法和链接很像。 行内形式（title 是选择性的）： ![alt text](/path/to/img.jpg &quot;Title&quot;) 参考形式： ![alt text][id] [id]: /path/to/img.jpg &quot;Title&quot; 上面两种方法都会输出 HTML 为： &lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt; 代码在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码： I strongly recommend against using any `&lt;blink&gt;` tags. I wish SmartyPants used named entities like `&amp;mdash;` instead of decimal-encoded entites like `&amp;#8212;`. 输出 HTML 为： &lt;p&gt;I strongly recommend against using any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; &lt;p&gt;I wish SmartyPants used named entities like &lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encoded entites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt; 如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。 Markdown 语法: If you want your page to validate under XHTML 1.0 Strict, you&apos;ve got to put paragraph tags in your blockquotes: &lt;blockquote&gt; &lt;p&gt;For example.&lt;/p&gt; &lt;/blockquote&gt; 输出 HTML 为： &lt;p&gt;If you want your page to validate under XHTML 1.0 Strict, you&apos;ve got to put paragraph tags in your blockquotes:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt; &amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt; &amp;lt;/blockquote&amp;gt; &lt;/code&gt;&lt;/pre&gt;]]></content>
  </entry>
</search>
